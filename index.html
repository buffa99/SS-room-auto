<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ショートステイ部屋割アプリ</title>
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  
  <!-- React & ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  
  <!-- Babel (JSX変換用) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- Firebase SDK (Compat) -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
  
  <style>
    @media print {
      @page {
        size: A3 landscape;
        margin: 2mm;
      }
      body {
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
        background: white;
        font-size: 6px !important;
      }
      .print-hidden {
        display: none !important;
      }
      .print-block {
        display: block !important;
      }
      .print-min-w-full {
        min-width: 100% !important;
        width: 100% !important;
      }
      .print-text-10px {
        font-size: 6px !important;
      }
      .print-static {
        position: static !important;
      }
      .print-shadow-none {
        box-shadow: none !important;
      }
      .print-col-span-5 {
        grid-column: span 5 / span 5 !important;
      }
      .print-border-none {
        border: none !important;
      }
      .print-p-0 {
        padding: 0 !important;
      }
      .print-placeholder-transparent::placeholder {
        color: transparent;
      }
      input {
        border: none !important;
        border-top: 1px solid #999 !important;
        font-size: 5px !important;
        height: 8px !important;
      }
      /* A3横長に収めるための設定 */
      table {
        width: 100% !important;
        min-width: unset !important;
        table-layout: fixed !important;
        font-size: 6px !important;
        transform-origin: top left;
      }
      th, td {
        padding: 0px !important;
        overflow: hidden !important;
        word-break: break-all !important;
        height: auto !important;
        min-height: unset !important;
        border-width: 1px !important;
      }
      /* 部屋列 */
      th:first-child, td:first-child {
        width: 32px !important;
        min-width: 32px !important;
        max-width: 32px !important;
        font-size: 7px !important;
      }
      /* 実績列 */
      th:last-child, td:last-child {
        width: 16px !important;
        min-width: 16px !important;
        max-width: 16px !important;
      }
      /* 通常の部屋セル */
      tbody td {
        height: 36px !important;
        vertical-align: top !important;
      }
      /* セル内のdiv */
      td > div {
        max-height: 34px !important;
        overflow: hidden !important;
      }
      .overflow-x-auto {
        overflow: visible !important;
      }
      h2.print-block {
        font-size: 10px !important;
        margin-bottom: 1px !important;
      }
      /* 部屋番号 */
      .text-3xl {
        font-size: 7px !important;
      }
      .text-2xl {
        font-size: 6px !important;
      }
      .text-xl {
        font-size: 6px !important;
      }
      .text-lg {
        font-size: 5px !important;
      }
      /* 利用者名 */
      td span {
        font-size: 6px !important;
        line-height: 1.0 !important;
        display: inline !important;
      }
      /* 利用者セル */
      .flex-1 {
        padding: 0 !important;
      }
      /* 各利用者の行 */
      td .p-0\.5, td .p-1 {
        padding: 0px !important;
        font-size: 6px !important;
        min-height: 8px !important;
      }
      /* 入浴・リネンアイコンを横に配置して小さく */
      td .flex.justify-center.gap-1 {
        display: inline !important;
        margin-left: 1px !important;
      }
      td .flex.justify-center.gap-1 span {
        font-size: 4px !important;
        padding: 0 !important;
        margin: 0 !important;
      }
      /* 入退マークを非表示 */
      td .text-\[7px\] {
        display: none !important;
      }
      /* 空床利用部屋も含める */
      tr {
        page-break-inside: avoid !important;
      }
      /* 日付ヘッダー */
      th .text-sm {
        font-size: 5px !important;
      }
      /* 特徴タグを非表示 */
      td:first-child .flex.flex-wrap {
        display: none !important;
      }
      /* ===== 実績行を小さく ===== */
      tfoot tr.bg-yellow-100 {
        height: 12px !important;
      }
      tfoot tr.bg-yellow-100 td {
        height: 12px !important;
        padding: 0 !important;
      }
      tfoot tr.bg-yellow-100 span {
        font-size: 7px !important;
      }
      /* ===== キャンセル待ち等（カスタム行）- 2段構成 ===== */
      tr.bg-sky-50 {
        height: 14px !important;
      }
      tr.bg-sky-50 td {
        height: 14px !important;
        padding: 0 !important;
        border: 1px solid #666 !important;
      }
      tr.bg-sky-50 td:first-child {
        font-size: 5px !important;
        white-space: nowrap !important;
        background-color: #bae6fd !important;
      }
      tr.bg-sky-50 input {
        height: 6px !important;
        font-size: 5px !important;
        border: none !important;
        border-bottom: 1px solid #ccc !important;
      }
      tr.bg-sky-50 input:last-child {
        border-bottom: none !important;
      }
      /* ===== 空床利用部屋を小さく（名前＋メモの2段のみ） ===== */
      tr.bg-purple-50 {
        height: 21px !important;
      }
      tr.bg-purple-50 td {
        height: 21px !important;
        border: 1px solid #666 !important;
      }
      /* 空床利用の部屋名セル（左端）を横書きで縮小 */
      tr.bg-purple-50 td:first-child {
        font-size: 5px !important;
        white-space: nowrap !important;
        overflow: hidden !important;
        text-overflow: clip !important;
        line-height: 1.0 !important;
        background-color: #fef9c3 !important;
      }
      tr.bg-purple-50 td:first-child .text-base,
      tr.bg-purple-50 td:first-child .font-bold {
        font-size: 5px !important;
      }
      /* 空床利用の名前部分 */
      tr.bg-purple-50 .flex-1 {
        max-height: 12px !important;
      }
      tr.bg-purple-50 .text-xs {
        font-size: 6px !important;
      }
      /* 空床利用のメモ欄を小さく */
      tr.bg-purple-50 input {
        height: 8px !important;
        font-size: 6px !important;
        border-top: 1px solid #ccc !important;
      }
      /* 空床の日付ヘッダー行を縮小 */
      tfoot tr td.border-purple-400.bg-purple-100,
      tfoot tr td.bg-purple-100 {
        height: 14px !important;
        padding: 0 !important;
      }
      /* 空床ヘッダーの「空床」文字を横書き縮小 */
      tfoot tr td.bg-purple-100.text-center {
        font-size: 5px !important;
        white-space: nowrap !important;
      }
      tfoot tr td.border-purple-400 .text-xs {
        font-size: 5px !important;
        line-height: 1.0 !important;
      }
      tfoot tr td.border-purple-400 .text-xs div {
        display: inline !important;
      }
      /* 空床実績・合計実績の左端セルを横書き縮小 */
      tfoot tr.bg-purple-100 td:first-child,
      tfoot tr.bg-green-100 td:first-child {
        font-size: 5px !important;
        white-space: nowrap !important;
      }
      /* 空床実績行 */
      tfoot tr.bg-purple-100 {
        height: 12px !important;
      }
      tfoot tr.bg-purple-100 td {
        height: 12px !important;
        padding: 0 !important;
      }
      /* 合計実績行 */
      tfoot tr.bg-green-100 {
        height: 12px !important;
      }
      tfoot tr.bg-green-100 td {
        height: 12px !important;
        padding: 0 !important;
      }
      /* 日付ヘッダー行 */
      thead tr {
        height: 18px !important;
      }
      thead th {
        height: 18px !important;
      }
      /* 空床用日付ヘッダー */
      tr td.border-purple-400 .text-xs {
        font-size: 5px !important;
      }
    }
    .dragging {
      opacity: 0.5;
      transform: scale(1.1);
    }
    .drag-over {
      background-color: #fef3c7 !important;
      border: 2px dashed #f59e0b !important;
    }
    /* 縦書き */
    .writing-mode-vertical {
      writing-mode: vertical-rl;
      text-orientation: mixed;
    }
    /* 横スクロールバーを常時表示 */
    .scroll-always-visible {
      overflow: scroll !important;
      scrollbar-gutter: stable;
    }
    .scroll-always-visible::-webkit-scrollbar {
      width: 16px !important;
      height: 16px !important;
      display: block !important;
    }
    .scroll-always-visible::-webkit-scrollbar-thumb {
      background: #666 !important;
      border-radius: 8px;
      border: 3px solid #f1f1f1;
      min-height: 40px;
    }
    .scroll-always-visible::-webkit-scrollbar-thumb:hover {
      background: #444 !important;
    }
    .scroll-always-visible::-webkit-scrollbar-track {
      background: #e0e0e0 !important;
    }
    .scroll-always-visible::-webkit-scrollbar-corner {
      background: #e0e0e0 !important;
    }
    /* Firefox用 */
    @supports (scrollbar-width: auto) {
      .scroll-always-visible {
        scrollbar-width: auto;
        scrollbar-color: #666 #e0e0e0;
      }
    }
    /* 同時編集用スタイル */
    .connected-users-panel {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      padding: 12px;
      z-index: 9999;
      max-width: 280px;
    }
    .user-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 14px;
    }
    .editing-cell {
      outline: 3px solid var(--editor-color, #3b82f6) !important;
      outline-offset: -1px;
    }
    .editor-label {
      position: absolute;
      top: -18px;
      left: 0;
      font-size: 10px;
      padding: 1px 4px;
      border-radius: 3px;
      color: white;
      white-space: nowrap;
      z-index: 100;
    }
  </style>
</head>
<body class="bg-gray-50 text-gray-800">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    // ① ここに、Firebaseコンソールからコピーした “値” を入れる
    const FIREBASE_CONFIG = {
      apiKey: "AIzaSyD9wXPT4uQ2SNfVf2lFEjqArBnaEmgslTI",
      authDomain: "ss-room-auto-1f9b3.firebaseapp.com",
      projectId: "ss-room-auto-1f9b3",
      storageBucket: "ss-room-auto-1f9b3.firebasestorage.app",
      messagingSenderId: "264240171286",
      appId: "1:264240171286:web:45c9beba0e241ce064a837"
    };

    // ② Firestore を RTDBっぽく扱うアダプタ（database.ref().set/update/on を再現）
    function makeFirestoreRtdbAdapter(docRef) {
      const norm = (p) => (p || "").replace(/^\/+|\/+$/g, "");
      const stripDataPrefix = (p) => {
        const s = norm(p);
        if (s === "" || s === "data") return "";
        if (s.startsWith("data/")) return s.slice(5);
        return s; // 念のため
      };
      const toDotPath = (p) => stripDataPrefix(p).split("/").filter(Boolean).join(".");

      class Ref {
        constructor(path) {
          this.path = norm(path);
          this._unsub = null;
        }
        on(event, cb) {
          if (event !== "value") return;
          // どのパスでも「共有ドキュメント全体」を監視（あなたの実装に合う）
          this._unsub = docRef.onSnapshot((doc) => {
            const raw = doc.data() || {};
            // 初期化用のゴミを避けたい場合
            const { __init, ...data } = raw;
            cb({ val: () => data });
          });
        }
        off() {
          if (this._unsub) {
            this._unsub();
            this._unsub = null;
          }
        }
        async set(value) {
          const sub = stripDataPrefix(this.path);
          if (!sub) {
            // data 全体を置く（上書き事故を避けるため merge）
            return docRef.set(value || {}, { merge: true });
          }
          const dot = toDotPath(this.path);
          // updateはdocが無いと落ちるので set(merge) を使う
          return docRef.set({ [dot]: value }, { merge: true });
        }
        async update(updates) {
          // updates: { "data/xxx": value, ... } を dot に変換して update
          const out = {};
          for (const [k, v] of Object.entries(updates || {})) {
            const dot = toDotPath(k);
            out[dot] = v;
          }
          return docRef.update(out);
        }
        // 既存コードの handleRoomDrop で transaction が使われているため追加
        transaction(updateFn) {
          return docRef.get().then(doc => {
            const raw = doc.data() || {};
            const dot = toDotPath(this.path);
            const current = dot ? raw[dot] : raw;
            const next = updateFn(current);
            if (next !== undefined) {
              return dot ? docRef.update({ [dot]: next }) : docRef.set(next, { merge: true });
            }
          });
        }
      }

      return {
        ref: (path = "") => new Ref(path),
      };
    }

    // ③ 初期化
    let database = null;
    let isFirebaseEnabled = false;

    // ============================================
    // ユーザー識別用ID生成
    // ============================================
    const generateUserId = () => {
      let userId = localStorage.getItem('shortstay_user_id');
      if (!userId) {
        userId = 'user_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('shortstay_user_id', userId);
      }
      return userId;
    };

    const generateUserColor = (userId) => {
      const colors = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#14b8a6', '#3b82f6', '#8b5cf6', '#ec4899'];
      let hash = 0;
      for (let i = 0; i < userId.length; i++) {
        hash = userId.charCodeAt(i) + ((hash << 5) - hash);
      }
      return colors[Math.abs(hash) % colors.length];
    };

    const generateUserName = () => {
      const adjectives = ['青い', '赤い', '緑の', '黄色い', '紫の', '白い', '黒い', 'オレンジ'];
      const animals = ['パンダ', 'キツネ', 'タヌキ', 'ウサギ', 'クマ', 'ネコ', 'イヌ', 'トリ'];
      return adjectives[Math.floor(Math.random() * adjectives.length)] + animals[Math.floor(Math.random() * animals.length)];
    };

    const CURRENT_USER_ID = generateUserId();
    const CURRENT_USER_COLOR = generateUserColor(CURRENT_USER_ID);
    const CURRENT_USER_NAME = localStorage.getItem('shortstay_user_name') || generateUserName();
    localStorage.setItem('shortstay_user_name', CURRENT_USER_NAME);

    // ============================================
    // 設定: パスワードはここで変更可能
    // 本番環境ではNetlify Identity等の利用を推奨
    // ============================================
    const APP_CONFIG = {
      // パスワード設定（初期パスワード）
      defaultPassword: 'keijuen2025',
      // 施設名
      facilityName: '特養ショートステイ',
      // セッション有効期限（ミリ秒）: 8時間
      sessionDuration: 8 * 60 * 60 * 1000,
    };

    // パスワード管理関数
    const getPassword = () => {
      const savedPassword = localStorage.getItem('shortstay_password');
      return savedPassword || APP_CONFIG.defaultPassword;
    };

    const setPassword = (newPassword) => {
      localStorage.setItem('shortstay_password', newPassword);
    };

    // --- アイコンコンポーネント ---
    const IconWrapper = ({ children, size = 24, className = "" }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{children}</svg>
    );
    const RefreshCw = (props) => <IconWrapper {...props}><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" /><path d="M21 3v5h-5" /><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" /><path d="M8 16H3v5" /></IconWrapper>;
    const User = (props) => <IconWrapper {...props}><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" /><circle cx="12" cy="7" r="4" /></IconWrapper>;
    const Plus = (props) => <IconWrapper {...props}><line x1="12" y1="5" x2="12" y2="19" /><line x1="5" y1="12" x2="19" y2="12" /></IconWrapper>;
    const Trash2 = (props) => <IconWrapper {...props}><polyline points="3 6 5 6 21 6" /><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" /><line x1="10" y1="11" x2="10" y2="17" /><line x1="14" y1="11" x2="14" y2="17" /></IconWrapper>;
    const Edit = (props) => <IconWrapper {...props}><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" /><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" /></IconWrapper>;
    const MapPin = (props) => <IconWrapper {...props}><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z" /><circle cx="12" cy="10" r="3" /></IconWrapper>;
    const ChevronLeft = (props) => <IconWrapper {...props}><polyline points="15 18 9 12 15 6" /></IconWrapper>;
    const ChevronRight = (props) => <IconWrapper {...props}><polyline points="9 18 15 12 9 6" /></IconWrapper>;
    const CalendarIcon = (props) => <IconWrapper {...props}><rect x="3" y="4" width="18" height="18" rx="2" ry="2" /><line x1="16" y1="2" x2="16" y2="6" /><line x1="8" y1="2" x2="8" y2="6" /><line x1="3" y1="10" x2="21" y2="10" /></IconWrapper>;
    const Printer = (props) => <IconWrapper {...props}><polyline points="6 9 6 2 18 2 18 9" /><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2" /><rect x="6" y="14" width="12" height="8" /></IconWrapper>;
    const Save = (props) => <IconWrapper {...props}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" /><polyline points="17 21 17 13 7 13 7 21" /><polyline points="7 3 7 8 15 8" /></IconWrapper>;
    const LogOut = (props) => <IconWrapper {...props}><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" /><polyline points="16 17 21 12 16 7" /><line x1="21" y1="12" x2="9" y2="12" /></IconWrapper>;
    const Settings = (props) => <IconWrapper {...props}><circle cx="12" cy="12" r="3" /><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z" /></IconWrapper>;
    const Lock = (props) => <IconWrapper {...props}><rect x="3" y="11" width="18" height="11" rx="2" ry="2" /><path d="M7 11V7a5 5 0 0 1 10 0v4" /></IconWrapper>;
    const Download = (props) => <IconWrapper {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="7 10 12 15 17 10" /><line x1="12" y1="15" x2="12" y2="3" /></IconWrapper>;
    const Upload = (props) => <IconWrapper {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="17 8 12 3 7 8" /><line x1="12" y1="3" x2="12" y2="15" /></IconWrapper>;
    const Search = (props) => <IconWrapper {...props}><circle cx="11" cy="11" r="8" /><line x1="21" y1="21" x2="16.65" y2="16.65" /></IconWrapper>;

    // メモ入力用コンポーネント（パフォーマンス最適化：onBlurで保存）
    const MemoInput = ({ value, onSave, className, placeholder }) => {
      const [localValue, setLocalValue] = useState(value || '');

      useEffect(() => {
        setLocalValue(value || '');
      }, [value]);

      const handleBlur = () => {
        if (localValue !== (value || '')) {
          onSave(localValue);
        }
      };

      const handleKeyDown = (e) => {
        if (e.key === 'Enter') {
          e.target.blur();
        }
      };

      return (
        <input
          type="text"
          value={localValue}
          onChange={(e) => setLocalValue(e.target.value)}
          onBlur={handleBlur}
          onKeyDown={handleKeyDown}
          className={className}
          placeholder={placeholder}
        />
      );
    };

    // --- 設定値 ---
    const INITIAL_ROOMS = [
      { id: '201', name: '201', features: ['low_fall_risk'], label: '転倒リスク低' },
      { id: '202', name: '202', features: [], label: '通常' },
      { id: '203', name: '203', features: [], label: '通常' },
      { id: '204', name: '204', features: ['near_toilet', 'for_high_fall_risk'], label: 'トイレ近・転倒リスク高' },
      { id: '205', name: '205', features: ['for_oxygen'], label: '在宅酸素推奨' },
      { id: '206', name: '206', features: ['low_fall_risk'], label: '転倒リスク低' },
      { id: '207', name: '207', features: ['near_toilet'], label: 'トイレ近' },
      { id: '208', name: '208', features: ['near_toilet', 'for_new', 'for_high_fall_risk'], label: 'トイレ近・新規向・転倒リスク高' },
      { id: '209', name: '209', features: ['for_high_fall_risk'], label: '転倒リスク高' },
      { id: '210', name: '210', features: ['for_oxygen'], label: '在宅酸素推奨' },
    ];

    const WEEK_DAYS_JP = ['日', '月', '火', '水', '木', '金', '土'];

    // 日本の祝日（2024-2026年）
    const HOLIDAYS_JP = {
      '2024-01-01': '元日', '2024-01-08': '成人の日', '2024-02-11': '建国記念の日', '2024-02-12': '振替休日',
      '2024-02-23': '天皇誕生日', '2024-03-20': '春分の日', '2024-04-29': '昭和の日', '2024-05-03': '憲法記念日',
      '2024-05-04': 'みどりの日', '2024-05-05': 'こどもの日', '2024-05-06': '振替休日', '2024-07-15': '海の日',
      '2024-08-11': '山の日', '2024-08-12': '振替休日', '2024-09-16': '敬老の日', '2024-09-22': '秋分の日',
      '2024-09-23': '振替休日', '2024-10-14': 'スポーツの日', '2024-11-03': '文化の日', '2024-11-04': '振替休日',
      '2024-11-23': '勤労感謝の日', '2025-01-01': '元日', '2025-01-13': '成人の日', '2025-02-11': '建国記念の日',
      '2025-02-23': '天皇誕生日', '2025-02-24': '振替休日', '2025-03-20': '春分の日', '2025-04-29': '昭和の日',
      '2025-05-03': '憲法記念日', '2025-05-04': 'みどりの日', '2025-05-05': 'こどもの日', '2025-05-06': '振替休日',
      '2025-07-21': '海の日', '2025-08-11': '山の日', '2025-09-15': '敬老の日', '2025-09-23': '秋分の日',
      '2025-10-13': 'スポーツの日', '2025-11-03': '文化の日', '2025-11-23': '勤労感謝の日', '2025-11-24': '振替休日',
      '2026-01-01': '元日', '2026-01-12': '成人の日', '2026-02-11': '建国記念の日', '2026-02-23': '天皇誕生日',
      '2026-03-20': '春分の日', '2026-04-29': '昭和の日', '2026-05-03': '憲法記念日', '2026-05-04': 'みどりの日',
      '2026-05-05': 'こどもの日', '2026-05-06': '振替休日', '2026-07-20': '海の日', '2026-08-11': '山の日',
      '2026-09-21': '敬老の日', '2026-09-22': '国民の休日', '2026-09-23': '秋分の日', '2026-10-12': 'スポーツの日',
      '2026-11-03': '文化の日', '2026-11-23': '勤労感謝の日',
    };

    const isHoliday = (dateStr) => HOLIDAYS_JP[dateStr] !== undefined;

    // 入浴方法
    const BATH_TYPES = [
      { key: 'individual', label: '個浴' },
      { key: 'lift', label: 'リフト浴' },
      { key: 'intermediate', label: '中間浴' },
      { key: 'bed', label: '臥床浴' },
    ];

    // ========== 食事伝票関連の定数 ==========
    // 食種
    const MEAL_FOOD_TYPES = [
      { key: 'normal_1400', label: '普通食Ⅰ(1400kcal)' },
      { key: 'soft', label: '軟菜' },
      { key: 'normal_1600', label: '普通食Ⅱ(1600kcal)' },
      { key: 'diabetes', label: '糖尿病食' }, // kcal入力あり
      { key: 'gastric_ulcer', label: '胃潰瘍食' },
      { key: 'anemia', label: '貧血食' },
      { key: 'liver', label: '肝臓食' },
      { key: 'dyslipidemia', label: '脂質異常食' },
      { key: 'kidney', label: '腎臓食' },
      { key: 'cardiac', label: '心高食(c1 5g以下)' },
      { key: 'low_salt', label: '減塩食(c1 6g以下)' },
      { key: 'gastrostomy', label: '胃ろう' },
      { key: 'jelly', label: 'ゼリー食' },
      { key: 'dysphagia', label: '嚥下食' },
    ];
    // 主食
    const MEAL_MAIN_DISH = [
      { key: 'rice', label: '米飯' },
      { key: 'soft_rice', label: '軟飯' },
      { key: 'onigiri', label: 'おにぎり' },
      { key: 'porridge', label: '全粥' },
      { key: 'mousse_porridge', label: 'ムース粥' },
      { key: 'other', label: 'その他' },
    ];
    // 副食
    const MEAL_SIDE_DISH = [
      { key: 'regular', label: '常菜' },
      { key: 'soft', label: '軟菜' },
      { key: 'bite_size', label: '一口大' },
      { key: 'minced', label: '刻み' },
      { key: 'mousse', label: 'ムース' },
      { key: 'other', label: 'その他' },
    ];
    // 飲み物
    const MEAL_DRINK = [
      { key: 'normal', label: '通常' },
      { key: 'thickened', label: 'トロミ' },
    ];
    // 間食
    const MEAL_SNACK = [
      { key: 'normal', label: '通常' },
      { key: 'jelly', label: 'ゼリー対応' },
    ];
    // 食事タイミング
    const MEAL_TIMING = [
      { key: 'breakfast', label: '朝' },
      { key: 'snack1', label: '間1' },
      { key: 'lunch', label: '昼' },
      { key: 'snack2', label: '間2' },
      { key: 'dinner', label: '夕' },
    ];
    // 区分
    const MEAL_CATEGORY = [
      { key: 'start', label: '開始' },
      { key: 'change', label: '変更' },
      { key: 'stop', label: '中止' },
    ];
    // 理由
    const MEAL_REASON = [
      { key: 'ss_repeater_tree', label: 'SS(リピーター：樹)' },
      { key: 'ss_repeater_vacancy', label: 'SS(リピーター：空床)' },
      { key: 'ss_new_tree', label: 'SS(新規：樹)' },
      { key: 'ss_new_vacancy', label: 'SS(新規：空床)' },
      { key: 'ss_change', label: 'SS変更(〇前⇒後)' },
      { key: 'ss_stop', label: 'SS食止め' },
    ];

    // --- 定数 ---
    const TEMP_ROOM_1_ID = 'TEMP1';
    const TEMP_ROOM_2_ID = 'TEMP2';
    const TEMP_ROOM_PREFIX = 'TEMP_ROOM_';

    // --- 日付ヘルパー ---
    // 日付文字列をローカルタイムゾーンでパース（タイムゾーン問題を回避）
    const parseLocalDate = (dateStr) => {
      const [year, month, day] = dateStr.split('-').map(Number);
      return new Date(year, month - 1, day);
    };

    const getFirstDayOfMonth = (d) => new Date(d.getFullYear(), d.getMonth(), 1);
    const getDaysInMonth = (d) => new Date(d.getFullYear(), d.getMonth() + 1, 0).getDate();
    const toDateStr = (d) => `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
    
    // カタカナをひらがなに変換（ソート用）
    const katakanaToHiragana = (str) => {
      return str.replace(/[\u30A1-\u30F6]/g, (match) => {
        return String.fromCharCode(match.charCodeAt(0) - 0x60);
      });
    };
    
    // ひらがなをカタカナに変換（フリガナ入力用）
    const hiraganaToKatakana = (str) => {
      return str.replace(/[\u3041-\u3096]/g, (match) => {
        return String.fromCharCode(match.charCodeAt(0) + 0x60);
      });
    };
    const addMonths = (d, n) => new Date(d.getFullYear(), d.getMonth() + n, 1);
    const getPrevDay = (dateStr) => {
      const d = parseLocalDate(dateStr);
      d.setDate(d.getDate() - 1);
      return toDateStr(d);
    };
    const getNextDay = (dateStr) => {
      const d = parseLocalDate(dateStr);
      d.setDate(d.getDate() + 1);
      return toDateStr(d);
    };

    // 範囲日付取得（タイムゾーン対応版）
    const getDatesInRange = (startStr, endStr) => {
      const dates = [];
      const d1 = parseLocalDate(startStr);
      const d2 = parseLocalDate(endStr);
      
      let current = d1 <= d2 ? new Date(d1) : new Date(d2);
      const end = d1 <= d2 ? new Date(d2) : new Date(d1);

      while (current <= end) {
        dates.push(toDateStr(current));
        current.setDate(current.getDate() + 1);
      }
      return dates;
    };

    // --- スケジュール初期計算ロジック ---
    // 連続した利用期間を取得
    const getStayPeriods = (stayDates) => {
      const sortedDates = [...stayDates].sort();
      if (sortedDates.length === 0) return [];

      const periods = [];
      let currentPeriod = [sortedDates[0]];
      
      for (let i = 1; i < sortedDates.length; i++) {
        const prev = parseLocalDate(sortedDates[i-1]);
        const curr = parseLocalDate(sortedDates[i]);
        const diff = (curr - prev) / (1000 * 60 * 60 * 24);
        
        if (diff === 1) {
          currentPeriod.push(sortedDates[i]);
        } else {
          periods.push(currentPeriod);
          currentPeriod = [sortedDates[i]];
        }
      }
      periods.push(currentPeriod);
      return periods;
    };

    const calculateInitialSchedule = (stayDates, bathType = '') => {
      const schedule = {};
      const sortedDates = [...stayDates].sort();
      if (sortedDates.length === 0) return schedule;

      const periods = [];
      let currentPeriod = [sortedDates[0]];
      
      for (let i = 1; i < sortedDates.length; i++) {
        const prev = parseLocalDate(sortedDates[i-1]);
        const curr = parseLocalDate(sortedDates[i]);
        const diff = (curr - prev) / (1000 * 60 * 60 * 24);
        
        if (diff === 1) {
          currentPeriod.push(sortedDates[i]);
        } else {
          periods.push(currentPeriod);
          currentPeriod = [sortedDates[i]];
        }
      }
      periods.push(currentPeriod);

      // 入浴方法に応じた曜日判定関数
      const getBathDays = (bathType) => {
        switch (bathType) {
          case 'intermediate': // 中間浴: 水曜日(3)と土曜日(6)
            return { primary: [3, 6], secondary: null };
          case 'bed': // 臥床浴: 火曜日(2)と金曜日(5)、ダメなら水曜日(3)と土曜日(6)
            return { primary: [2, 5], secondary: [3, 6] };
          case 'individual': // 個浴: 曜日制限なし
          case 'lift': // リフト浴: 曜日制限なし
          default:
            return { primary: null, secondary: null };
        }
      };

      const bathDays = getBathDays(bathType);

      // 対象曜日かどうかチェック
      const isValidBathDay = (dateStr) => {
        if (bathDays.primary === null) return true; // 曜日制限なし
        const dayOfWeek = parseLocalDate(dateStr).getDay();
        if (bathDays.primary.includes(dayOfWeek)) return true;
        if (bathDays.secondary && bathDays.secondary.includes(dayOfWeek)) return true;
        return false;
      };

      // 優先曜日かどうかチェック
      const isPrimaryBathDay = (dateStr) => {
        if (bathDays.primary === null) return true;
        const dayOfWeek = parseLocalDate(dateStr).getDay();
        return bathDays.primary.includes(dayOfWeek);
      };

      periods.forEach(period => {
        const daysInPeriod = period.length;
        
        // 初期化: すべての日を入浴なしに
        period.forEach((dateStr) => {
          schedule[dateStr] = { bath: false, mustBath: false, linen: false };
        });

        // 最終日（帰宅前日）は必ず入浴（mustBath）
        const lastDayIndex = daysInPeriod - 1;
        schedule[period[lastDayIndex]].mustBath = true;
        schedule[period[lastDayIndex]].bath = true;

        // 入浴スケジュール計算
        // ルール：
        // - 週2回（3-4日に1回）
        // - 帰宅前日は必須
        // - 2泊3日(3日), 3泊4日(4日) → 1回（帰宅前日のみ）
        // - 4泊5日(5日)以上 → 週2回ペース

        if (daysInPeriod >= 5) {
          // 帰宅前日から逆算して、3-4日おきに入浴を設定
          // 入浴間隔は3-4日（週2回ペース）
          const BATH_INTERVAL = 4; // 4日間隔（週2回相当）
          
          let lastBathIndex = lastDayIndex; // 帰宅前日
          let nextBathTarget = lastBathIndex - BATH_INTERVAL;
          
          while (nextBathTarget >= 0) {
            // nextBathTarget付近（±1日）で最適な入浴日を探す
            let bestIndex = -1;
            const searchStart = Math.max(0, nextBathTarget - 1);
            const searchEnd = Math.min(lastDayIndex - 1, nextBathTarget + 1);
            
            // 優先曜日で探す
            for (let i = searchStart; i <= searchEnd; i++) {
              if (isPrimaryBathDay(period[i]) && !schedule[period[i]].bath) {
                bestIndex = i;
                break;
              }
            }
            
            // なければ対象曜日で探す
            if (bestIndex === -1) {
              for (let i = searchStart; i <= searchEnd; i++) {
                if (isValidBathDay(period[i]) && !schedule[period[i]].bath) {
                  bestIndex = i;
                  break;
                }
              }
            }
            
            // それでもなければ、ターゲット位置に設定
            if (bestIndex === -1) {
              bestIndex = Math.max(0, Math.min(nextBathTarget, lastDayIndex - 1));
            }
            
            // 入浴を設定（既に設定済みでなければ）
            if (bestIndex >= 0 && bestIndex < lastDayIndex && !schedule[period[bestIndex]].bath) {
              schedule[period[bestIndex]].bath = true;
              lastBathIndex = bestIndex;
            }
            
            // 次のターゲット
            nextBathTarget = nextBathTarget - BATH_INTERVAL;
          }
        }

        // リネン交換: 7日ごと
        period.forEach((dateStr, index) => {
          if ((index + 1) % 7 === 0 && daysInPeriod >= 7) {
            schedule[dateStr].linen = true;
          }
        });
      });

      return schedule;
    };

    // --- サンプルデータ生成 ---
    const generateSampleUsers = (baseDate) => {
      const year = baseDate.getFullYear();
      const month = baseDate.getMonth();
      const makeDate = (day) => toDateStr(new Date(year, month, day));
      const daysInMonth = getDaysInMonth(baseDate);
      const allDays = Array.from({ length: daysInMonth }, (_, i) => makeDate(i + 1));
      
      const sampleData = [
        { id: 1, name: 'Ａ様', conditions: ['home_oxygen'], stayDates: allDays },
        { id: 2, name: '佐藤様', conditions: ['near_toilet', 'high_fall_risk'], stayDates: allDays.filter((_, i) => i + 1 <= 15) },
        { id: 3, name: '鈴木様', conditions: ['low_fall_risk'], stayDates: allDays.filter((_, i) => i + 1 >= 15) },
        { id: 4, name: '田中様(新)', conditions: ['is_new'], stayDates: allDays.slice(0, 8) },
        { id: 5, name: '高橋様', conditions: ['high_fall_risk'], stayDates: allDays.slice(10, 20) },
      ];

      return sampleData.map(u => ({
        ...u,
        schedule: calculateInitialSchedule(u.stayDates, u.bathType || ''),
        createdAt: new Date().toISOString(),
        isArchived: false,
        fixedRooms: {},
        bathType: ''
      }));
    };

    // ============================================
    // 認証コンポーネント
    // ============================================
    function LoginScreen() {
      const [email, setEmail] = useState('');
      const [password, setPassword] = useState('');
      const [showPassword, setShowPassword] = useState(false);
      const [error, setError] = useState('');
      const [isLoading, setIsLoading] = useState(false);

      const handleSubmit = async (e) => {
        e.preventDefault();
        setIsLoading(true);
        setError('');

        try {
          await firebase.auth().signInWithEmailAndPassword(email, password);
        } catch (err) {
          console.error("Login error:", err);
          let msg = 'ログインに失敗しました';
          if (err.code === 'auth/invalid-email') msg = 'メールアドレスの形式が正しくありません';
          if (err.code === 'auth/user-disabled') msg = 'このユーザーは無効化されています';
          if (err.code === 'auth/user-not-found') msg = 'ユーザーが見つかりません';
          if (err.code === 'auth/wrong-password') msg = 'パスワードが間違っています';
          if (err.code === 'auth/invalid-credential') msg = '認証情報が正しくありません';
          setError(msg);
          setIsLoading(false);
        }
      };

      return (
        <div className="min-h-screen bg-gray-100 flex items-center justify-center p-4">
          <div className="bg-white rounded-xl shadow-lg p-8 w-full max-w-md">
            <div className="text-center mb-8">
              <h1 className="text-2xl font-bold text-gray-800">{APP_CONFIG.facilityName}</h1>
              <p className="text-gray-500 mt-2">ログイン</p>
            </div>

            <form onSubmit={handleSubmit} className="space-y-6">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  メールアドレス
                </label>
                <input
                  type="email"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition-colors"
                  placeholder="name@example.com"
                  required
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  パスワード
                </label>
                <div className="relative">
                  <input
                    type={showPassword ? "text" : "password"}
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition-colors pr-10"
                    placeholder="パスワードを入力"
                    required
                  />
                  <button
                    type="button"
                    onClick={() => setShowPassword(!showPassword)}
                    className="absolute inset-y-0 right-0 pr-3 flex items-center text-gray-500 hover:text-gray-700 focus:outline-none"
                  >
                    {showPassword ? (
                      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
                        <path strokeLinecap="round" strokeLinejoin="round" d="M3.98 8.223A10.477 10.477 0 001.934 12C3.226 16.338 7.244 19.5 12 19.5c.993 0 1.953-.138 2.863-.395M6.228 6.228A10.45 10.45 0 0112 4.5c4.756 0 8.773 3.162 10.065 7.498a10.523 10.523 0 01-4.293 5.774M6.228 6.228L3 3m3.228 3.228l3.65 3.65m7.894 7.894L21 21m-3.228-3.228l-3.65-3.65m0 0a3 3 0 10-4.243-4.243m4.242 4.242L9.88 9.88" />
                      </svg>
                    ) : (
                      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
                        <path strokeLinecap="round" strokeLinejoin="round" d="M2.036 12.322a1.012 1.012 0 010-.639C3.423 7.51 7.36 4.5 12 4.5c4.638 0 8.573 3.007 9.963 7.178.07.207.07.431 0 .639C20.577 16.49 16.64 19.5 12 19.5c-4.638 0-8.573-3.007-9.963-7.178z" />
                        <path strokeLinecap="round" strokeLinejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                      </svg>
                    )}
                  </button>
                </div>
              </div>

              {error && (
                <div className="text-red-500 text-sm font-bold bg-red-50 p-3 rounded">
                  {error}
                </div>
              )}

              <button
                type="submit"
                disabled={isLoading}
                className="w-full bg-blue-600 hover:bg-blue-700 disabled:bg-blue-300 text-white font-bold py-3 px-4 rounded-lg transition-colors flex items-center justify-center gap-2"
              >
                {isLoading ? (
                  'ログイン中...'
                ) : (
                  'ログイン'
                )}
              </button>
            </form>

            <p className="mt-6 text-center text-xs text-gray-400">
              © 2025 ShortStay Room Allocation System
            </p>
          </div>
        </div>
      );
    }

    // ============================================
    // メインアプリコンポーネント
    // ============================================
    function ShortStayAllocator({ onLogout }) {
      const [currentMonth, setCurrentMonth] = useState(getFirstDayOfMonth(new Date()));
      const [rooms, setRooms] = useState(INITIAL_ROOMS);
      const [showRoomEditor, setShowRoomEditor] = useState(false);
      const [editingRooms, setEditingRooms] = useState([]);
      const [tempRooms, setTempRooms] = useState([]); // 空床利用部屋
      const [editingTempRoom, setEditingTempRoom] = useState(null); // 編集中の空床部屋
      
      const [users, setUsers] = useState([]);
      const [allocations, setAllocations] = useState({}); 
      const [memos, setMemos] = useState({}); 
      const [customRows, setCustomRows] = useState([{ id: 'cancel-wait', name: 'キャンセル待ち' }]); // カスタム行
      const [customRowMemos, setCustomRowMemos] = useState({}); // カスタム行のメモ
      const [isLoaded, setIsLoaded] = useState(false);
      
      const [newUserOpen, setNewUserOpen] = useState(false);
      const [editingUser, setEditingUser] = useState(null); 
      const [newUserData, setNewUserData] = useState({ 
        name: '', 
        furigana: '', 
        gender: '', // 性別: 'male' or 'female'
        birthDate: '', // 生年月日: 'YYYY-MM-DD'
        birthDateMode: 'wareki', // 'wareki' or 'western'
        birthEra: '', // reiwa, heisei, showa, taisho
        birthYear: '',
        birthMonth: '',
        birthDay: '',
        conditions: [], 
        stayDates: [], 
        fixedRooms: {}, 
        bathType: '',
        // 医療情報
        medical: { insulin: false, gastrostomy: false, oxygenTherapy: false },
        // 送迎データ
        transport: { pickupTime: '', dropoffTime: '', address: '', pickupMethod: '', wheelchairNeeded: false, note: '' },
        // 居宅介護支援事業所
        careManager: { officeName: '', staffName: '', phone: '', fax: '', mobile: '' }
      });
      
      const [selectionStart, setSelectionStart] = useState(null);
      const [calendarMonth, setCalendarMonth] = useState(currentMonth); // カレンダー選択用の月
      const [userSortOrder, setUserSortOrder] = useState('asc'); // 'asc' = 昇順(あ→ん), 'desc' = 降順(ん→あ)
      const [userSearchQuery, setUserSearchQuery] = useState(''); // 利用者検索
      const [displayStartDate, setDisplayStartDate] = useState(''); // 表示開始日
      const [displayEndDate, setDisplayEndDate] = useState(''); // 表示終了日
      const [useCustomRange, setUseCustomRange] = useState(false); // カスタム期間表示モード
      const [showSettings, setShowSettings] = useState(false); // 設定モーダル
      const [headerCollapsed, setHeaderCollapsed] = useState(false); // ヘッダー折りたたみ
      const [sidebarCollapsed, setSidebarCollapsed] = useState(false); // サイドバー折りたたみ
      const [currentPassword, setCurrentPassword] = useState('');
      const [newPassword, setNewPassword] = useState('');
      const [confirmPassword, setConfirmPassword] = useState('');
      const [settingsError, setSettingsError] = useState('');
      const [settingsSuccess, setSettingsSuccess] = useState('');
      const [lastBackup, setLastBackup] = useState(null);
      const [showLogoutConfirm, setShowLogoutConfirm] = useState(false);
      const [archiveYear, setArchiveYear] = useState('');
      const [showArchiveConfirm, setShowArchiveConfirm] = useState(false);
      const [archiveStats, setArchiveStats] = useState(null);
      const tableContainerRef = React.useRef(null);
      
      // 食事伝票関連のstate
      const [mealTickets, setMealTickets] = useState({}); // { "userId_startDate_endDate": {...} }
      const [showMealTicketModal, setShowMealTicketModal] = useState(false);
      const [editingMealTicket, setEditingMealTicket] = useState(null); // 編集中の伝票情報
      
      // 横スクロール関数
      const scrollTable = (direction) => {
        if (tableContainerRef.current) {
          const scrollAmount = 300;
          tableContainerRef.current.scrollBy({
            left: direction === 'left' ? -scrollAmount : scrollAmount,
            behavior: 'smooth'
          });
        }
      };
      
      const [dragItem, setDragItem] = useState(null);
      const [dragOverTarget, setDragOverTarget] = useState(null);
      
      // 利用者の部屋移動用ドラッグ状態
      const [dragUser, setDragUser] = useState(null); // { userId, date, fromRoomId }
      const [dragOverRoom, setDragOverRoom] = useState(null); // "date-roomId"
      
      // 右クリックコンテキストメニュー用
      const [contextMenu, setContextMenu] = useState(null); // { x, y, userId, date, fromRoomId }

      const fileInputRef = useRef(null);

      const STORAGE_KEY_USERS = 'shortstay_users_v1';
      const STORAGE_KEY_ALLOCATIONS = 'shortstay_allocations_v1';
      const STORAGE_KEY_MEMOS = 'shortstay_memos_v1';
      const STORAGE_KEY_LAST_BACKUP = 'shortstay_last_backup';
      const STORAGE_KEY_ROOMS = 'shortstay_rooms_v1';
      const STORAGE_KEY_TEMP_ROOMS = 'shortstay_temp_rooms_v1';
      const STORAGE_KEY_MEAL_TICKETS = 'shortstay_meal_tickets_v1';
      const STORAGE_KEY_CUSTOM_ROWS = 'shortstay_custom_rows_v1';
      const STORAGE_KEY_CUSTOM_ROW_MEMOS = 'shortstay_custom_row_memos_v1';

      // --- データ永続化層（Firebase対応版） ---
      // Firebaseが有効ならFirebaseを使用、無効ならlocalStorageを使用
      const db = {
        load: (key) => {
          try {
            const item = localStorage.getItem(key);
            return item ? JSON.parse(item) : null;
          } catch (e) {
            console.error(`Load Error (${key}):`, e);
            return null;
          }
        },
        save: (key, data) => {
          // ローカルストレージへの保存のみに役割を変更
          localStorage.setItem(key, JSON.stringify(data));
        },
        remove: (key) => {
          localStorage.removeItem(key);
          if (isFirebaseEnabled && database) {
            database.ref('data/' + key).remove().catch(e => console.error('Firebase remove error:', e));
          }
        }
      };

      // 同時編集用のstate
      const [connectedUsers, setConnectedUsers] = useState([]);
      const [syncStatus, setSyncStatus] = useState(isFirebaseEnabled ? 'connected' : 'disconnected');

      useEffect(() => {
        const savedUsers = db.load(STORAGE_KEY_USERS);
        const savedAllocations = db.load(STORAGE_KEY_ALLOCATIONS);
        const savedMemos = db.load(STORAGE_KEY_MEMOS);

        if (savedUsers) {
          try {
            const migratedUsers = savedUsers.map(u => {
              // 古いデータの互換性対応
              const migrated = { ...u };
              if (!migrated.schedule) {
                migrated.schedule = calculateInitialSchedule(migrated.stayDates, migrated.bathType || '');
              }
              if (migrated.isArchived === undefined) {
                migrated.isArchived = false;
              }
              if (!migrated.createdAt) {
                migrated.createdAt = new Date().toISOString();
              }
              // fixedRoom → fixedRooms マイグレーション
              if (migrated.fixedRooms === undefined) {
                migrated.fixedRooms = {};
                // 古いfixedRoomがあれば、全期間に適用
                if (migrated.fixedRoom) {
                  const periods = getStayPeriods(migrated.stayDates || []);
                  periods.forEach(period => {
                    const periodKey = `${period[0]}_${period[period.length - 1]}`;
                    migrated.fixedRooms[periodKey] = migrated.fixedRoom;
                  });
                }
                delete migrated.fixedRoom;
              }
              if (migrated.bathType === undefined) {
                migrated.bathType = '';
              }
              if (migrated.furigana === undefined) {
                migrated.furigana = '';
              }
              return migrated;
            });
            setUsers(migratedUsers);
          } catch (e) {
            console.error('ユーザーデータの読み込みエラー:', e);
            setUsers(generateSampleUsers(new Date()));
          }
        } else {
          setUsers(generateSampleUsers(new Date()));
        }

        if (savedAllocations) {
          try { setAllocations(savedAllocations); } catch (e) {
            console.error('割り当てデータの読み込みエラー:', e);
          }
        }
        if (savedMemos) {
          try { setMemos(savedMemos); } catch (e) {
            console.error('メモデータの読み込みエラー:', e);
          }
        }
        
        // 部屋設定を読み込み
        const savedRooms = db.load(STORAGE_KEY_ROOMS);
        if (savedRooms) {
          try { setRooms(savedRooms); } catch (e) {
            console.error('部屋データの読み込みエラー:', e);
          }
        }
        
        // 空床利用部屋を読み込み
        const savedTempRooms = db.load(STORAGE_KEY_TEMP_ROOMS);
        if (savedTempRooms) {
          try { setTempRooms(savedTempRooms); } catch (e) {
            console.error('空床利用部屋の読み込みエラー:', e);
          }
        }
        
        // 食事伝票を読み込み
        const savedMealTickets = db.load(STORAGE_KEY_MEAL_TICKETS);
        if (savedMealTickets) {
          try { setMealTickets(savedMealTickets); } catch (e) {
            console.error('食事伝票の読み込みエラー:', e);
          }
        }
        
        // カスタム行を読み込み
        const savedCustomRows = db.load(STORAGE_KEY_CUSTOM_ROWS);
        if (savedCustomRows) {
          try { setCustomRows(savedCustomRows); } catch (e) {
            console.error('カスタム行の読み込みエラー:', e);
          }
        }
        
        // カスタム行メモを読み込み
        const savedCustomRowMemos = db.load(STORAGE_KEY_CUSTOM_ROW_MEMOS);
        if (savedCustomRowMemos) {
          try { setCustomRowMemos(savedCustomRowMemos); } catch (e) {
            console.error('カスタム行メモの読み込みエラー:', e);
          }
        }
        
        // 最終バックアップ日時を読み込み
        const savedLastBackup = localStorage.getItem(STORAGE_KEY_LAST_BACKUP); // バックアップ情報はローカルでOK
        if (savedLastBackup) {
          setLastBackup(new Date(savedLastBackup));
        }
        
        setIsLoaded(true);

        // Firebaseリアルタイムリスナーの設定
        if (isFirebaseEnabled && database) {
          // 接続ユーザーの管理
          const presenceRef = database.ref('presence/' + CURRENT_USER_ID);
          const connectedRef = database.ref('.info/connected');
          
          connectedRef.on('value', (snap) => {
            if (snap.val() === true) {
              setSyncStatus('connected');
              presenceRef.set({
                id: CURRENT_USER_ID,
                name: CURRENT_USER_NAME,
                color: CURRENT_USER_COLOR,
                lastSeen: firebase.database.ServerValue.TIMESTAMP
              });
              presenceRef.onDisconnect().remove();
            } else {
              setSyncStatus('disconnected');
            }
          });

          // 接続ユーザー一覧の監視
          database.ref('presence').on('value', (snap) => {
            const users = [];
            snap.forEach((child) => {
              users.push(child.val());
            });
            setConnectedUsers(users);
          });

          // データ変更のリアルタイム監視
          const dataRef = database.ref('data');
          dataRef.on('value', (snap) => {
            const data = snap.val();
            if (data) {
              if (data[STORAGE_KEY_USERS]) setUsers(data[STORAGE_KEY_USERS]);
              if (data[STORAGE_KEY_ALLOCATIONS]) setAllocations(data[STORAGE_KEY_ALLOCATIONS]);
              if (data[STORAGE_KEY_MEMOS]) setMemos(data[STORAGE_KEY_MEMOS]);
              if (data[STORAGE_KEY_ROOMS]) setRooms(data[STORAGE_KEY_ROOMS]);
              if (data[STORAGE_KEY_TEMP_ROOMS]) setTempRooms(data[STORAGE_KEY_TEMP_ROOMS]);
              if (data[STORAGE_KEY_MEAL_TICKETS]) setMealTickets(data[STORAGE_KEY_MEAL_TICKETS]);
              if (data[STORAGE_KEY_CUSTOM_ROWS]) setCustomRows(data[STORAGE_KEY_CUSTOM_ROWS]);
              if (data[STORAGE_KEY_CUSTOM_ROW_MEMOS]) setCustomRowMemos(data[STORAGE_KEY_CUSTOM_ROW_MEMOS]);
            }
          });

          // クリーンアップ
          return () => {
            connectedRef.off();
            database.ref('presence').off();
            dataRef.off();
            presenceRef.remove();
          };
        }
      }, []);

      useEffect(() => {
        if (!isLoaded) return;
        // 変更を常にローカルストレージにバックアップ（オフライン用）
        db.save(STORAGE_KEY_USERS, users);
      }, [users, isLoaded]);

      useEffect(() => {
        if (!isLoaded) return;
        // 変更を常にローカルストレージにバックアップ（オフライン用）
        db.save(STORAGE_KEY_ALLOCATIONS, allocations);
      }, [allocations, isLoaded]);

      useEffect(() => {
        if (!isLoaded) return;
        // 変更を常にローカルストレージにバックアップ（オフライン用）
        db.save(STORAGE_KEY_MEMOS, memos);
      }, [memos, isLoaded]);

      useEffect(() => {
        if (!isLoaded) return;
        // 変更を常にローカルストレージにバックアップ（オフライン用）
        db.save(STORAGE_KEY_ROOMS, rooms);
      }, [rooms, isLoaded]);

      useEffect(() => {
        if (!isLoaded) return;
        // 変更を常にローカルストレージにバックアップ（オフライン用）
        db.save(STORAGE_KEY_TEMP_ROOMS, tempRooms);
      }, [tempRooms, isLoaded]);

      useEffect(() => {
        if (!isLoaded) return;
        // 変更を常にローカルストレージにバックアップ（オフライン用）
        db.save(STORAGE_KEY_MEAL_TICKETS, mealTickets);
      }, [mealTickets, isLoaded]);

      useEffect(() => {
        if (!isLoaded) return;
        // 変更を常にローカルストレージにバックアップ（オフライン用）
        db.save(STORAGE_KEY_CUSTOM_ROWS, customRows);
      }, [customRows, isLoaded]);

      useEffect(() => {
        if (!isLoaded) return;
        // 変更を常にローカルストレージにバックアップ（オフライン用）
        db.save(STORAGE_KEY_CUSTOM_ROW_MEMOS, customRowMemos);
      }, [customRowMemos, isLoaded]);

      // 部屋の特徴オプション
      const ROOM_FEATURES = [
        { key: 'near_toilet', label: 'トイレ近' },
        { key: 'for_high_fall_risk', label: '転倒リスク高向け' },
        { key: 'low_fall_risk', label: '転倒リスク低向け' },
        { key: 'for_oxygen', label: '在宅酸素推奨' },
        { key: 'for_new', label: '新規向け' },
      ];

      const CONDITIONS = [
        { key: 'is_new', label: '新規利用者' },
        { key: 'near_toilet', label: 'トイレ近く' },
        { key: 'high_fall_risk', label: '転倒リスク高' },
        { key: 'low_fall_risk', label: '転倒リスク低' },
        { key: 'home_oxygen', label: '在宅酸素' },
      ];

      const daysInMonth = getDaysInMonth(currentMonth);
      const currentMonthDates = Array.from({ length: daysInMonth }, (_, i) => {
        return toDateStr(new Date(currentMonth.getFullYear(), currentMonth.getMonth(), i + 1));
      });

      // 表示用の日付配列（カスタム期間またはmonth全体）
      const displayDates = React.useMemo(() => {
        if (useCustomRange && displayStartDate && displayEndDate) {
          const dates = [];
          let current = parseLocalDate(displayStartDate);
          const end = parseLocalDate(displayEndDate);
          while (current <= end) {
            dates.push(toDateStr(current));
            current = new Date(current.getFullYear(), current.getMonth(), current.getDate() + 1);
          }
          return dates;
        }
        return currentMonthDates;
      }, [useCustomRange, displayStartDate, displayEndDate, currentMonthDates]);

      // 表示日数に応じたセル幅
      const cellWidth = React.useMemo(() => {
        const days = displayDates.length;
        if (days <= 3) return 'min-w-[150px]';
        if (days <= 7) return 'min-w-[100px]';
        if (days <= 14) return 'min-w-[70px]';
        return 'min-w-[48px]';
      }, [displayDates.length]);

      // 当月の空床利用部屋のみフィルタリング
      const currentMonthTempRooms = React.useMemo(() => {
        const monthStr = `${currentMonth.getFullYear()}-${String(currentMonth.getMonth() + 1).padStart(2, '0')}`;
        return tempRooms.filter(r => r.month === monthStr);
      }, [tempRooms, currentMonth]);

      // パフォーマンス改善：部屋ごとの利用者の色（0:ピンク, 1:スカイブルー）を事前に一括計算
      const roomUserColors = React.useMemo(() => {
        const colorMap = {}; // キー: "roomId-userId", 値: 0 or 1
        if (currentMonthDates.length === 0) return {};

        rooms.forEach(room => {
            const userAppearanceOrder = new Map(); // この部屋でユーザーが初めて現れた順序を記録
            let orderCounter = 0;

            // 月初から月末まで走査して、利用者が初めて現れた順に番号を付ける
            currentMonthDates.forEach(dateStr => {
                const key = `${dateStr}-${room.id}`;
                const userIds = allocations[key] || [];
                
                userIds.forEach(userId => {
                    if (!userAppearanceOrder.has(userId)) {
                        userAppearanceOrder.set(userId, orderCounter % 2);
                        orderCounter++;
                    }
                });
            });

            // 結果をマップに保存
            userAppearanceOrder.forEach((colorIndex, userId) => {
                colorMap[`${room.id}-${userId}`] = colorIndex;
            });
        });

        return colorMap;
      }, [allocations, rooms, currentMonthDates]);

      // --- データエクスポート ---
      // --- PDF生成（食事伝票） ---
      const generateMealTicketPDF = (ticket) => {
        const user = users.find(u => u.id === ticket.userId);
        if (!user) {
          alert('利用者情報が見つかりません');
          return;
        }
        
        // 日付をフォーマット
        const formatDate = (dateStr) => {
          if (!dateStr) return '';
          const d = parseLocalDate(dateStr);
          const reiwa = d.getFullYear() - 2018;
          return `令和${reiwa}年${d.getMonth()+1}月${d.getDate()}日`;
        };
        
        // 生年月日から和暦と年齢を計算
        const formatBirthDate = (dateStr) => {
          if (!dateStr) return { warekiStr: '', age: '' };
          const d = parseLocalDate(dateStr);
          const year = d.getFullYear();
          let era = '';
          let eraYear = 0;
          if (year >= 2019) { era = '令和'; eraYear = year - 2018; }
          else if (year >= 1989) { era = '平成'; eraYear = year - 1988; }
          else if (year >= 1926) { era = '昭和'; eraYear = year - 1925; }
          else { era = '大正'; eraYear = year - 1911; }
          const warekiStr = `${era}${eraYear}年${d.getMonth()+1}月${d.getDate()}日`;
          
          // 年齢計算
          const today = new Date();
          let age = today.getFullYear() - d.getFullYear();
          const m = today.getMonth() - d.getMonth();
          if (m < 0 || (m === 0 && today.getDate() < d.getDate())) age--;
          
          return { warekiStr, age };
        };
        
        const birthInfo = formatBirthDate(user.birthDate);
        const genderMark = user.gender === 'male' ? '○' : '';
        const genderMarkF = user.gender === 'female' ? '○' : '';
        
        // ラベル取得関数
        const getLabel = (arr, key) => arr.find(a => a.key === key)?.label || '';
        
        // HTMLでPDFを生成
        const printWindow = window.open('', '_blank');
        printWindow.document.write(`
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="UTF-8">
            <title>食事指示箋 - ${user.name}</title>
            <style>
              @page { size: A4; margin: 10mm; }
              * { -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important; color-adjust: exact !important; }
              body { font-family: "Yu Gothic", "游ゴシック", sans-serif; font-size: 11px; margin: 0; padding: 15px; }
              h1 { text-align: center; font-size: 18px; margin-bottom: 5px; }
              .header-container { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px; }
              .stamp-area { display: flex; gap: 5px; }
              .stamp-box { width: 50px; height: 50px; border: 1px solid #333; text-align: center; font-size: 9px; }
              .stamp-box .label { border-bottom: 1px solid #333; padding: 2px; background: #f0f0f0; }
              .stamp-box .space { height: 35px; }
              table { width: 100%; border-collapse: collapse; margin-bottom: 8px; }
              th, td { border: 1px solid #333; padding: 6px 8px; text-align: left; height: 24px; }
              th { background-color: #f0f0f0; font-weight: bold; width: 70px; }
              .checkbox { display: inline-block; width: 12px; height: 12px; border: 2px solid #333; margin-right: 3px; vertical-align: middle; position: relative; top: -1px; }
              .checked { background-color: #000 !important; }
              .option-item { display: inline-block; margin-right: 12px; white-space: nowrap; font-size: 10px; line-height: 16px; vertical-align: middle; }
              .memo-cell { height: 72px; vertical-align: top; }
            </style>
          </head>
          <body>
            <div class="header-container">
              <div></div>
              <h1 style="flex-grow: 1;">ショートステイ　食事指示箋</h1>
              <div class="stamp-area">
                <div class="stamp-box"><div class="label">医師</div><div class="space"></div></div>
                <div class="stamp-box"><div class="label">栄養課</div><div class="space"></div></div>
                <div class="stamp-box"><div class="label">記入者</div><div class="space"></div></div>
              </div>
            </div>
            
            <table>
              <tr>
                <th>フリガナ</th>
                <td colspan="5">${user.furigana || ''}</td>
              </tr>
              <tr>
                <th>氏名</th>
                <td colspan="5" style="font-size: 14px; font-weight: bold;">${user.name}</td>
              </tr>
              <tr>
                <th>性別</th>
                <td>${genderMark}男　・　${genderMarkF}女</td>
                <th>生年月日</th>
                <td>${birthInfo.warekiStr}</td>
                <th>年齢</th>
                <td>${birthInfo.age}歳</td>
              </tr>
              <tr>
                <th>ユニット</th>
                <td colspan="5">${ticket.unit || ''}</td>
              </tr>
            </table>
            
            <table>
              <tr>
                <th>区分</th>
                <td colspan="5">
                  <span class="option-item"><span class="checkbox ${ticket.category === 'start' ? 'checked' : ''}"></span>開始</span>
                  <span class="option-item"><span class="checkbox ${ticket.category === 'change' ? 'checked' : ''}"></span>変更</span>
                  <span class="option-item"><span class="checkbox ${ticket.category === 'stop' ? 'checked' : ''}"></span>中止</span>
                </td>
              </tr>
              <tr>
                <th>理由</th>
                <td colspan="5">
                  <span class="option-item"><span class="checkbox ${ticket.reason === 'ss_repeater_tree' ? 'checked' : ''}"></span>SS(リピーター：樹)</span>
                  <span class="option-item"><span class="checkbox ${ticket.reason === 'ss_repeater_vacancy' ? 'checked' : ''}"></span>SS(リピーター：空床)</span>
                  <span class="option-item"><span class="checkbox ${ticket.reason === 'ss_new_tree' ? 'checked' : ''}"></span>SS(新規：樹)</span>
                  <span class="option-item"><span class="checkbox ${ticket.reason === 'ss_new_vacancy' ? 'checked' : ''}"></span>SS(新規：空床)</span>
                  <br>
                  <span class="option-item"><span class="checkbox ${ticket.reason === 'ss_change' ? 'checked' : ''}"></span>SS変更(〇前⇒後)</span>
                  <span class="option-item"><span class="checkbox ${ticket.reason === 'ss_stop' ? 'checked' : ''}"></span>SS食止め</span>
                </td>
              </tr>
            </table>
            
            <table>
              <tr>
                <th>開始日</th>
                <td colspan="5">${formatDate(ticket.startDate)}　${getLabel(MEAL_TIMING, ticket.startMeal)}　から</td>
              </tr>
              <tr>
                <th>終了日</th>
                <td colspan="5">${formatDate(ticket.endDate)}　${getLabel(MEAL_TIMING, ticket.endMeal)}　まで</td>
              </tr>
            </table>
            
            <table>
              <tr>
                <th>食種</th>
                <td colspan="5">
                  ${MEAL_FOOD_TYPES.map(f => `
                    <span class="option-item"><span class="checkbox ${ticket.foodType === f.key ? 'checked' : ''}"></span>${f.label}${f.key === 'diabetes' && ticket.foodType === 'diabetes' ? `(${ticket.diabetesKcal || '　'}kcal)` : ''}</span>
                  `).join('')}
                </td>
              </tr>
              <tr>
                <th>主食</th>
                <td colspan="5">
                  ${MEAL_MAIN_DISH.map(m => `
                    <span class="option-item"><span class="checkbox ${ticket.mainDish === m.key ? 'checked' : ''}"></span>${m.label}${m.key === 'other' && ticket.mainDish === 'other' ? `(${ticket.mainDishOther || ''})` : ''}</span>
                  `).join('')}
                </td>
              </tr>
              <tr>
                <th>副食</th>
                <td colspan="5">
                  ${MEAL_SIDE_DISH.map(s => `
                    <span class="option-item"><span class="checkbox ${ticket.sideDish === s.key ? 'checked' : ''}"></span>${s.label}${s.key === 'other' && ticket.sideDish === 'other' ? `(${ticket.sideDishOther || ''})` : ''}</span>
                  `).join('')}
                </td>
              </tr>
              <tr>
                <th>飲み物</th>
                <td colspan="5">
                  ${MEAL_DRINK.map(d => `
                    <span class="option-item"><span class="checkbox ${ticket.drink === d.key ? 'checked' : ''}"></span>${d.label}</span>
                  `).join('')}
                </td>
              </tr>
              <tr>
                <th>間食</th>
                <td colspan="5">
                  ${MEAL_SNACK.map(s => `
                    <span class="option-item"><span class="checkbox ${ticket.snack === s.key ? 'checked' : ''}"></span>${s.label}</span>
                  `).join('')}
                </td>
              </tr>
              <tr>
                <th>メモ</th>
                <td colspan="5" class="memo-cell">${ticket.memo || ''}</td>
              </tr>
            </table>
            
            <scr` + `ipt>
              window.onload = function() {
                window.print();
              }
            </scr` + `ipt>
          </body>
          </html>
        `);
        printWindow.document.close();
      };

      const exportData = () => {
        const data = {
          version: '1.0',
          exportedAt: new Date().toISOString(),
          users,
          allocations,
          memos,
          rooms,
          tempRooms,
          mealTickets
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `shortstay-backup-${toDateStr(new Date())}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        // バックアップ日時を保存
        const now = new Date();
        localStorage.setItem(STORAGE_KEY_LAST_BACKUP, now.toISOString());
        setLastBackup(now);
      };

      // --- 年度別アーカイブ機能 ---
      const getDataYears = () => {
        const years = new Set();
        
        // ユーザーの利用日からから年を抽出
        users.forEach(user => {
          user.stayDates.forEach(date => {
            years.add(date.substring(0, 4));
          });
        });
        
        // allocationsから年を抽出
        Object.keys(allocations).forEach(key => {
          const year = key.substring(0, 4);
          if (year.match(/^\d{4}$/)) {
            years.add(year);
          }
        });
        
        // memosから年を抽出
        Object.keys(memos).forEach(key => {
          const year = key.substring(0, 4);
          if (year.match(/^\d{4}$/)) {
            years.add(year);
          }
        });
        
        return Array.from(years).sort();
      };

      const calculateArchiveStats = (year) => {
        // 該当年のデータ数をカウント
        let stayDateCount = 0;
        let allocationCount = 0;
        let memoCount = 0;
        let affectedUsers = new Set();
        
        users.forEach(user => {
          const yearDates = user.stayDates.filter(d => d.startsWith(year));
          if (yearDates.length > 0) {
            stayDateCount += yearDates.length;
            affectedUsers.add(user.id);
          }
        });
        
        Object.keys(allocations).forEach(key => {
          if (key.startsWith(year)) allocationCount++;
        });
        
        Object.keys(memos).forEach(key => {
          if (key.startsWith(year)) memoCount++;
        });
        
        return {
          stayDateCount,
          allocationCount,
          memoCount,
          userCount: affectedUsers.size
        };
      };

      const exportYearData = (year) => {
        // 該当年のデータのみを抽出してエクスポート
        const yearUsers = users.map(user => ({
          ...user,
          stayDates: user.stayDates.filter(d => d.startsWith(year)),
          schedule: Object.fromEntries(
            Object.entries(user.schedule || {}).filter(([key]) => key.startsWith(year))
          )
        })).filter(u => u.stayDates.length > 0);

        const yearAllocations = Object.fromEntries(
          Object.entries(allocations).filter(([key]) => key.startsWith(year))
        );

        const yearMemos = Object.fromEntries(
          Object.entries(memos).filter(([key]) => key.startsWith(year))
        );

        const data = {
          version: '1.0',
          archiveYear: year,
          exportedAt: new Date().toISOString(),
          users: yearUsers,
          allocations: yearAllocations,
          memos: yearMemos
        };

        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `shortstay-archive-${year}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      };

      const deleteYearData = (year) => {
        // 該当年のデータを削除
        setUsers(prevUsers => prevUsers.map(user => ({
          ...user,
          stayDates: user.stayDates.filter(d => !d.startsWith(year)),
          schedule: Object.fromEntries(
            Object.entries(user.schedule || {}).filter(([key]) => !key.startsWith(year))
          )
        })));

        setAllocations(prev => Object.fromEntries(
          Object.entries(prev).filter(([key]) => !key.startsWith(year))
        ));

        setMemos(prev => Object.fromEntries(
          Object.entries(prev).filter(([key]) => !key.startsWith(year))
        ));
      };

      const executeArchive = (year) => {
        // 1. まず該当年のデータをエクスポート
        exportYearData(year);
        
        // 2. データを削除
        deleteYearData(year);
        
        // 3. 状態をリセット
        setArchiveYear('');
        setShowArchiveConfirm(false);
        setArchiveStats(null);
        setSettingsSuccess(`${year}年のデータをアーカイブしました`);
      };

      // --- データインポート ---
      const importData = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const data = JSON.parse(event.target.result);
            if (data.users && data.allocations) {
              if (window.confirm('現在のデータを上書きしますか？')) {
                setUsers(data.users);
                setAllocations(data.allocations);
                setMemos(data.memos || {});
                if (data.rooms) setRooms(data.rooms);
                if (data.tempRooms) setTempRooms(data.tempRooms);
                if (data.mealTickets) setMealTickets(data.mealTickets);
                alert('データをインポートしました');
              }
            } else {
              alert('無効なバックアップファイルです');
            }
          } catch (err) {
            alert('ファイルの読み込みに失敗しました');
          }
        };
        reader.readAsText(file);
        e.target.value = '';
      };

      // --- ドラッグ＆ドロップ ハンドラ ---
      const handleDragStart = (e, userId, date, type) => {
        setDragItem({ userId, date, type });
        e.dataTransfer.effectAllowed = 'move';
        e.target.classList.add('dragging');
      };

      const handleDragEnd = (e) => {
        e.target.classList.remove('dragging');
        setDragItem(null);
        setDragOverTarget(null);
      };

      const handleDragOver = (e, userId, date) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        if (dragItem && dragItem.userId === userId) {
          const target = `${userId}-${date}`;
          if (dragOverTarget !== target) {
            setDragOverTarget(target);
          }
        }
      };

      const handleDragLeave = (e) => {
        setDragOverTarget(null);
      };

      // --- 利用者の部屋移動用ドラッグ&ドロップ ---
      const handleUserDragStart = (e, userId, date, roomId) => {
        e.stopPropagation();
        setDragUser({ userId, date, fromRoomId: roomId });
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', `user-${userId}`);
      };

      const handleUserDragEnd = (e) => {
        setDragUser(null);
        setDragOverRoom(null);
      };

      // 右クリックでコンテキストメニュー表示
      const handleContextMenu = (e, userId, date, fromRoomId) => {
        e.preventDefault();
        setContextMenu({ x: e.clientX, y: e.clientY, userId, date, fromRoomId });
      };

      // コンテキストメニューを閉じる
      const closeContextMenu = () => {
        setContextMenu(null);
      };

      // コンテキストメニューから部屋を選択して移動
      const handleMoveToRoom = (targetRoomId) => {
        if (!contextMenu) return;
        const { userId, date, fromRoomId } = contextMenu;
        
        if (fromRoomId === targetRoomId) {
          closeContextMenu();
          return;
        }
        
        const user = users.find(u => u.id === userId);
        if (!user) {
          closeContextMenu();
          return;
        }

        const periods = getStayPeriods(user.stayDates);
        const currentPeriod = periods.find(p => p.includes(date));
        if (!currentPeriod) {
          closeContextMenu();
          return;
        }

        const targetDisplayName = targetRoomId === TEMP_ROOM_1_ID ? '一時保管①' :
                                  targetRoomId === TEMP_ROOM_2_ID ? '一時保管②' :
                                  targetRoomId.startsWith(TEMP_ROOM_PREFIX) ? (tempRooms.find(r => r.id === targetRoomId)?.name || '空床') :
                                  `${targetRoomId}号室`;
        const moveChoice = window.confirm(
          `${user.name}を${targetDisplayName}に移動します。\n\n` +
          `【OK】この利用期間全体（${currentPeriod[0]}〜${currentPeriod[currentPeriod.length-1]}）を移動\n` +
          `【キャンセル】${date}のみ移動`
        );

        const datesToMove = moveChoice ? currentPeriod : [date];
        
        // 一時保管以外への移動は重複チェック
        if (!targetRoomId.startsWith('TEMP')) { // 'TEMP'で始まるIDはすべて一時保管系とみなす
          let hasConflict = false;
          let conflictDates = [];
          
          for (const moveDate of datesToMove) {
            const targetKey = `${moveDate}-${targetRoomId}`;
            const targetOccupants = allocations[targetKey] || [];
            const otherOccupants = targetOccupants.filter(id => id !== userId);
            
            if (otherOccupants.length >= 2) {
              alert(`${moveDate}は${targetDisplayName}が満室のため移動できません`);
              closeContextMenu();
              return;
            }

            if (otherOccupants.length === 1) {
              const existingUserId = otherOccupants[0];
              const existingUser = users.find(u => u.id === existingUserId);
              if (existingUser) {
                const existingIsCheckIn = !existingUser.stayDates.includes(getPrevDay(moveDate));
                const existingIsCheckOut = !existingUser.stayDates.includes(getNextDay(moveDate));
                const movingIsCheckIn = !user.stayDates.includes(getPrevDay(moveDate));
                const movingIsCheckOut = !user.stayDates.includes(getNextDay(moveDate));
                const canShare = (existingIsCheckOut && movingIsCheckIn) || (existingIsCheckIn && movingIsCheckOut);
                if (!canShare) {
                  hasConflict = true;
                  conflictDates.push(`${moveDate}（${existingUser.name}と重複）`);
                }
              }
            }
          }
          
          if (hasConflict) {
            const confirmMove = window.confirm(
              `以下の日程で他の利用者と重複します：\n\n${conflictDates.join('\n')}\n\n` +
              `それでも${targetDisplayName}に移動しますか？`
            );
            if (!confirmMove) {
              closeContextMenu();
              return;
            }
          }
        }

        if (isFirebaseEnabled && database) {
          // Firebaseモード：トランザクションで安全にallocationsを更新
          const allocationsRef = database.ref('data/' + STORAGE_KEY_ALLOCATIONS);
          allocationsRef.transaction(currentAllocations => {
            if (!currentAllocations) currentAllocations = {};
            datesToMove.forEach(moveDate => {
              const fromKey = `${moveDate}-${fromRoomId}`;
              if (currentAllocations[fromKey]) {
                currentAllocations[fromKey] = currentAllocations[fromKey].filter(id => id !== userId);
                if (currentAllocations[fromKey].length === 0) {
                  delete currentAllocations[fromKey];
                }
              }
              const targetKey = `${moveDate}-${targetRoomId}`;
              const currentTarget = currentAllocations[targetKey] || [];
              if (!currentTarget.includes(userId)) {
                currentAllocations[targetKey] = [...currentTarget, userId];
              }
            });
            return currentAllocations;
          });
        } else {
          // ローカルモード
          const newAllocations = { ...allocations };
          datesToMove.forEach(moveDate => {
            const fromKey = `${moveDate}-${fromRoomId}`;
            if (newAllocations[fromKey]) {
              newAllocations[fromKey] = newAllocations[fromKey].filter(id => id !== userId);
              if (newAllocations[fromKey].length === 0) {
                delete newAllocations[fromKey];
              }
            }
            const targetKey = `${moveDate}-${targetRoomId}`;
            const currentTarget = newAllocations[targetKey] || [];
            if (!currentTarget.includes(userId)) {
              newAllocations[targetKey] = [...currentTarget, userId];
            }
          });
          setAllocations(newAllocations);
        }
        closeContextMenu();
      };

      const handleRoomDragOver = (e, date, roomId) => {
        e.preventDefault();
        if (dragUser) {
          // 同じ日付へのドラッグのみハイライト
          if (dragUser.date === date) {
            e.dataTransfer.dropEffect = 'move';
            const target = `${date}-${roomId}`;
            if (dragOverRoom !== target) {
              setDragOverRoom(target);
            }
          }
        }
      };

      const handleRoomDragLeave = (e) => {
        setDragOverRoom(null);
      };

      const handleRoomDrop = (e, date, roomId) => {
        e.preventDefault();
        setDragOverRoom(null);
        
        if (!dragUser || dragUser.date !== date) return;
        if (dragUser.fromRoomId === roomId) return;

        const { userId, fromRoomId } = dragUser;
        const user = users.find(u => u.id === userId);
        if (!user) return;

        // 一時保管部屋の場合は表示名を変更
        const roomDisplayName = roomId === TEMP_ROOM_1_ID ? '一時保管①' :
                                roomId === TEMP_ROOM_2_ID ? '一時保管②' :
                                roomId.startsWith(TEMP_ROOM_PREFIX) ? (tempRooms.find(r => r.id === roomId)?.name || '空床') :
                                `${roomId}号室`;

        // 現在の利用期間を特定
        const periods = getStayPeriods(user.stayDates);
        const currentPeriod = periods.find(p => p.includes(date));
        if (!currentPeriod) return;

        // 移動方法を選択
        const moveChoice = window.confirm(
          `${user.name}の居室を${roomDisplayName}に変更します。\n\n` +
          `【OK】この利用期間全体（${currentPeriod[0]}〜${currentPeriod[currentPeriod.length-1]}）を移動\n` +
          `【キャンセル】${date}のみ移動`
        );

        const datesToMove = moveChoice ? currentPeriod : [date];

        // 一時保管部屋への移動は制限なし
        if (!roomId.startsWith('TEMP')) { // 'TEMP'で始まるIDはすべて一時保管系とみなす
          // 移動先の部屋の空き状況を確認
          let hasConflict = false;
          let conflictDates = [];
          
          for (const moveDate of datesToMove) {
            const targetKey = `${moveDate}-${roomId}`;
            const targetOccupants = allocations[targetKey] || [];
            
            // 自分自身を除外してカウント
            const otherOccupants = targetOccupants.filter(id => id !== userId);
            
            if (otherOccupants.length >= 2) {
              alert(`${moveDate}は${roomDisplayName}が満室（3人以上）のため移動できません`);
              setDragUser(null);
              return;
            }

            // 1人いる場合、入退所日の相性チェック
            if (otherOccupants.length === 1) {
              const existingUserId = otherOccupants[0];
              const existingUser = users.find(u => u.id === existingUserId);
              if (existingUser) {
                const existingIsCheckIn = !existingUser.stayDates.includes(getPrevDay(moveDate));
                const existingIsCheckOut = !existingUser.stayDates.includes(getNextDay(moveDate));
                const movingIsCheckIn = !user.stayDates.includes(getPrevDay(moveDate));
                const movingIsCheckOut = !user.stayDates.includes(getNextDay(moveDate));
                const canShare = (existingIsCheckOut && movingIsCheckIn) || (existingIsCheckIn && movingIsCheckOut);
                if (!canShare) {
                  hasConflict = true;
                  conflictDates.push(`${moveDate}（${existingUser.name}と重複）`);
                }
              }
            }
          }
          
          // 重複がある場合は警告を出して確認
          if (hasConflict) {
            const confirmMove = window.confirm(
              `以下の日程で他の利用者と重複します：\n\n${conflictDates.join('\n')}\n\n` +
              `それでも${roomDisplayName}に移動しますか？\n（同日IN/OUTではない重複が発生します）`
            );
            if (!confirmMove) {
              setDragUser(null);
              return;
            }
          }
        }

        if (isFirebaseEnabled && database) {
          // Firebaseモード：トランザクションで安全にallocationsを更新
          const allocationsRef = database.ref('data/' + STORAGE_KEY_ALLOCATIONS);
          allocationsRef.transaction(currentAllocations => {
            if (currentAllocations === null) {
              currentAllocations = {};
            }
            // トランザクション内で最新のデータ(currentAllocations)に対して移動処理を行う
            datesToMove.forEach(moveDate => {
              // 元の部屋から削除
              const fromKey = `${moveDate}-${fromRoomId}`;
              if (currentAllocations[fromKey]) {
                currentAllocations[fromKey] = currentAllocations[fromKey].filter(id => id !== userId);
                if (currentAllocations[fromKey].length === 0) {
                  delete currentAllocations[fromKey];
                }
              }
              // 新しい部屋に追加
              const targetKey = `${moveDate}-${roomId}`;
              const currentTarget = currentAllocations[targetKey] || [];
              if (!currentTarget.includes(userId)) {
                currentAllocations[targetKey] = [...currentTarget, userId];
              }
            });
            return currentAllocations; // 更新後のデータを返す
          });
        } else {
          // ローカルモード：直接stateを更新
          const newAllocations = { ...allocations };
          datesToMove.forEach(moveDate => {
            const fromKey = `${moveDate}-${fromRoomId}`;
            if (newAllocations[fromKey]) {
              newAllocations[fromKey] = newAllocations[fromKey].filter(id => id !== userId);
              if (newAllocations[fromKey].length === 0) {
                delete newAllocations[fromKey];
              }
            }
            const targetKey = `${moveDate}-${roomId}`;
            const currentTarget = newAllocations[targetKey] || [];
            if (!currentTarget.includes(userId)) {
              newAllocations[targetKey] = [...currentTarget, userId];
            }
          });
          setAllocations(newAllocations);
        }
        setDragUser(null);
      };

      const handleDrop = (e, targetUserId, targetDate) => {
        e.preventDefault();
        setDragOverTarget(null);
        
        if (!dragItem) return;
        if (dragItem.userId !== targetUserId) return;
        if (dragItem.date === targetDate) return;

        const targetUserIndex = users.findIndex(u => u.id === targetUserId);
        if (targetUserIndex === -1) return;
        
        const targetUser = users[targetUserIndex];
        if (!targetUser.stayDates.includes(targetDate)) return;

        const newUsers = [...users];
        // ユーザーオブジェクトを複製して直接変更を防ぐ
        newUsers[targetUserIndex] = { ...newUsers[targetUserIndex] };
        const user = newUsers[targetUserIndex];
        const newSchedule = { ...user.schedule };
        
        if (newSchedule[dragItem.date]) {
          const sourceDay = { ...newSchedule[dragItem.date] };
          if (dragItem.type === 'bath' || dragItem.type === 'mustBath') {
            sourceDay.bath = false;
            sourceDay.mustBath = false;
          } else if (dragItem.type === 'linen') {
            sourceDay.linen = false;
          }
          newSchedule[dragItem.date] = sourceDay;
        }

        const targetDay = newSchedule[targetDate] ? { ...newSchedule[targetDate] } : { bath: false, mustBath: false, linen: false };
        if (dragItem.type === 'bath') {
          targetDay.bath = true;
        } else if (dragItem.type === 'mustBath') {
          targetDay.bath = true;
          targetDay.mustBath = true;
        } else if (dragItem.type === 'linen') {
          targetDay.linen = true;
        }
        newSchedule[targetDate] = targetDay;

        user.schedule = newSchedule;
        if (isFirebaseEnabled && database) {
          database.ref('data/' + STORAGE_KEY_USERS).set(newUsers);
        } else {
          setUsers(newUsers);
        }
        setDragItem(null);
      };

      // --- 単一ユーザーの自動割り振り（追加・更新時用） ---
      const allocateSingleUser = (user, existingAllocations = allocations, allUsers = users) => {
        const newAllocations = { ...existingAllocations };
        
        // このユーザーの既存割り当てを削除
        Object.keys(newAllocations).forEach(key => {
          if (newAllocations[key] && newAllocations[key].includes(user.id)) {
            newAllocations[key] = newAllocations[key].filter(id => id !== user.id);
            if (newAllocations[key].length === 0) {
              delete newAllocations[key];
            }
          }
        });

        // 連続した利用期間ごとに部屋を割り当て
        const periods = getStayPeriods(user.stayDates);
        
        periods.forEach(period => {
          const periodKey = `${period[0]}_${period[period.length - 1]}`;
          const fixedRoomForPeriod = user.fixedRooms && user.fixedRooms[periodKey];
          
          // この期間が部屋固定されている場合
          if (fixedRoomForPeriod) {
            period.forEach(dateStr => {
              const key = `${dateStr}-${fixedRoomForPeriod}`;
                const current = newAllocations[key] || [];
                if (!current.includes(user.id)) {
                  newAllocations[key] = [...current, user.id];
                }
            });
            return; // 次の期間へ
          }
          
          // 固定されていない期間は自動割り当て
          let bestRoom = null;
          let bestScore = -9999;

          rooms.forEach(room => {
            // この期間全体で使用可能かチェック
            let canUsePeriod = true;

            for (const dateStr of period) {
              const key = `${dateStr}-${room.id}`;
              const currentOccupants = newAllocations[key] || [];
              
              if (currentOccupants.length >= 2) {
                canUsePeriod = false;
                break;
              }
              
              if (currentOccupants.length === 1) {
                const existingUserId = currentOccupants[0];
                const existingUser = allUsers.find(u => u.id === existingUserId);
                if (existingUser) {
                  const isCheckIn = !user.stayDates.includes(getPrevDay(dateStr));
                  const isCheckOut = !user.stayDates.includes(getNextDay(dateStr));
                  const existingIsCheckIn = !existingUser.stayDates.includes(getPrevDay(dateStr));
                  const existingIsCheckOut = !existingUser.stayDates.includes(getNextDay(dateStr));
                  const canShare = (existingIsCheckOut && isCheckIn) || (existingIsCheckIn && isCheckOut);
                  if (!canShare) {
                    canUsePeriod = false;
                    break;
                  }
                }
              }
            }

            if (!canUsePeriod) return;

            // スコア計算
            let score = 0;
            
            if (user.conditions.includes('home_oxygen')) {
              if (room.features.includes('for_oxygen')) score += 1000; else score -= 500;
            } else {
              if (room.features.includes('for_oxygen')) score -= 20;
            }
            if (user.conditions.includes('high_fall_risk')) {
              if (room.features.includes('for_high_fall_risk')) score += 150;
              if (room.features.includes('near_toilet')) score += 80;
              if (room.features.includes('low_fall_risk')) score -= 50;
            }
            if (user.conditions.includes('is_new')) {
              if (room.features.includes('for_new')) score += 60;
              if (room.features.includes('near_toilet')) score += 30;
            }
            if (user.conditions.includes('near_toilet')) {
              if (room.features.includes('near_toilet')) score += 100; else score -= 50;
            }
            if (user.conditions.includes('low_fall_risk')) {
              if (room.features.includes('low_fall_risk')) score += 80;
            }

            if (score > bestScore) {
              bestScore = score;
              bestRoom = room;
            }
          });

          // 期間全体を同じ部屋に割り当て
          if (bestRoom) {
            period.forEach(dateStr => {
              const key = `${dateStr}-${bestRoom.id}`;
              if (!newAllocations[key]) newAllocations[key] = [];
              newAllocations[key].push(user.id);
            });
          } else {
            // フォールバック: 重複を許容して、重複が最も少ない部屋を選ぶ
            let fallbackRoom = null;
            let minConflicts = Infinity;
            let fallbackScore = -9999;
            
            rooms.forEach(room => {
              let conflictDays = 0;
              let hasFullDay = false;
              
              for (const dateStr of period) {
                const key = `${dateStr}-${room.id}`;
                const currentOccupants = newAllocations[key] || [];
                
                // 2人以上いる日がある部屋は除外
                if (currentOccupants.length >= 2) {
                  hasFullDay = true;
                  break;
                }
                
                // 1人いる場合、同日IN/OUTかどうかチェック
                if (currentOccupants.length === 1) {
                  const existingUserId = currentOccupants[0];
                  const existingUser = allUsers.find(u => u.id === existingUserId);
                  if (existingUser) {
                    const isCheckIn = !user.stayDates.includes(getPrevDay(dateStr));
                    const isCheckOut = !user.stayDates.includes(getNextDay(dateStr));
                    const existingIsCheckIn = !existingUser.stayDates.includes(getPrevDay(dateStr));
                    const existingIsCheckOut = !existingUser.stayDates.includes(getNextDay(dateStr));
                    const canShare = (existingIsCheckOut && isCheckIn) || (existingIsCheckIn && isCheckOut);
                    if (!canShare) {
                      conflictDays++; // 同日IN/OUTではない重複
                    }
                  }
                }
              }
              
              if (hasFullDay) return;
              
              // 条件スコア計算
              let score = 0;
              if (user.conditions.includes('home_oxygen')) {
                if (room.features.includes('for_oxygen')) score += 1000; else score -= 500;
              }
              if (user.conditions.includes('high_fall_risk')) {
                if (room.features.includes('for_high_fall_risk')) score += 150;
              }
              if (user.conditions.includes('near_toilet')) {
                if (room.features.includes('near_toilet')) score += 100;
              }
              
              // 重複が少ない部屋を優先、同じなら条件スコアで判断
              if (conflictDays < minConflicts || (conflictDays === minConflicts && score > fallbackScore)) {
                minConflicts = conflictDays;
                fallbackScore = score;
                fallbackRoom = room;
              }
            });
            
            if (fallbackRoom) {
              period.forEach(dateStr => {
                const key = `${dateStr}-${fallbackRoom.id}`;
                if (!newAllocations[key]) newAllocations[key] = [];
                newAllocations[key].push(user.id);
              });
            }
          }
        });

        return newAllocations;
      };

      // --- ユーザー登録・編集処理 ---
      const handleSaveUser = () => {
        if (!newUserData.name) return;

        let savedUser;
        let updatedUsers;
        let newPeriods = []; // 新しく追加された利用期間

        if (editingUser) {
          const oldPeriods = getStayPeriods(editingUser.stayDates);
          const currentPeriods = getStayPeriods(newUserData.stayDates);
          
          // 新しい期間を検出（既存の伝票がない期間）
          currentPeriods.forEach(period => {
            const periodStart = period[0];
            const periodEnd = period[period.length - 1];
            const ticketKey = `${editingUser.id}_${periodStart}_${periodEnd}`;
            const oldPeriodExists = oldPeriods.some(p => p[0] === periodStart && p[p.length-1] === periodEnd);
            if (!mealTickets[ticketKey] && !oldPeriodExists) {
              newPeriods.push({ start: periodStart, end: periodEnd, userId: editingUser.id });
            }
          });
          
          updatedUsers = users.map(u => {
            if (u.id === editingUser.id) {
              const datesChanged = JSON.stringify(u.stayDates.sort()) !== JSON.stringify(newUserData.stayDates.sort());
              const bathTypeChanged = u.bathType !== newUserData.bathType;
              const schedule = (datesChanged || bathTypeChanged) ? calculateInitialSchedule(newUserData.stayDates, newUserData.bathType) : u.schedule;
              savedUser = { ...newUserData, id: u.id, schedule };
              return savedUser;
            }
            return u;
          });
        } else {
          savedUser = { 
            ...newUserData, 
            id: Date.now(),
            schedule: calculateInitialSchedule(newUserData.stayDates, newUserData.bathType),
            createdAt: new Date().toISOString(),
            isArchived: false
          };
          updatedUsers = [...users, savedUser];
          
          // 新規ユーザーの場合、全期間が新規
          const periods = getStayPeriods(newUserData.stayDates);
          newPeriods = periods.map(p => ({ start: p[0], end: p[p.length-1], userId: savedUser.id }));
        }
        
        if (isFirebaseEnabled && database) {
          // Firebaseモード：usersとallocationsをアトミックに更新
          const newAllocations = (savedUser && savedUser.stayDates.length > 0)
            ? allocateSingleUser(savedUser, allocations, updatedUsers)
            : allocations;

          const updates = {};
          updates[`data/${STORAGE_KEY_USERS}`] = updatedUsers;
          updates[`data/${STORAGE_KEY_ALLOCATIONS}`] = newAllocations;

          database.ref().update(updates).catch((error) => {
            console.error('ユーザーと割り当ての更新に失敗しました: ', error);
            // ここでエラー処理（例：ユーザーに通知）を行うことができます
          });
        } else {
          // ローカルモード：stateを直接更新
          setUsers(updatedUsers);
          if (savedUser && savedUser.stayDates.length > 0) {
            const newAllocations = allocateSingleUser(savedUser, allocations, updatedUsers);
            setAllocations(newAllocations);
          }
        }
        
        setNewUserData({ 
          name: '', 
          furigana: '', 
          gender: '',
          birthDate: '',
          birthDateMode: 'wareki',
          birthEra: '',
          birthYear: '',
          birthMonth: '',
          birthDay: '',
          conditions: [], 
          stayDates: [], 
          fixedRooms: {}, 
          bathType: '',
          medical: { insulin: false, gastrostomy: false, oxygenTherapy: false },
          transport: { pickupTime: '', dropoffTime: '', address: '', pickupMethod: '', wheelchairNeeded: false, note: '' },
          careManager: { officeName: '', staffName: '', phone: '', fax: '', mobile: '' }
        });
        setEditingUser(null);
        setNewUserOpen(false);
        setSelectionStart(null);
        setCalendarMonth(currentMonth);
        
        // 新しい利用期間がある場合、食事伝票作成を確認
        if (newPeriods.length > 0) {
          const firstPeriod = newPeriods[0];
          if (window.confirm(`利用期間 ${firstPeriod.start} ～ ${firstPeriod.end} の食事伝票を作成しますか？`)) {
            setEditingMealTicket({
              userId: firstPeriod.userId,
              startDate: firstPeriod.start,
              endDate: firstPeriod.end,
              unit: '樹',
              startMeal: '',
              endMeal: '',
              category: '',
              reason: '',
              foodType: '',
              diabetesKcal: '',
              mainDish: '',
              mainDishOther: '',
              sideDish: '',
              sideDishOther: '',
              drink: '',
              snack: '',
              memo: ''
            });
            setShowMealTicketModal(true);
          }
        }
      };

      const handleEditUser = (user) => {
        setEditingUser(user);
        
        // 生年月日から和暦を計算
        let birthEra = '', birthYear = '', birthMonth = '', birthDay = '';
        if (user.birthDate) {
          const d = parseLocalDate(user.birthDate);
          const year = d.getFullYear();
          birthMonth = d.getMonth() + 1;
          birthDay = d.getDate();
          if (year >= 2019) { birthEra = 'reiwa'; birthYear = year - 2018; }
          else if (year >= 1989) { birthEra = 'heisei'; birthYear = year - 1988; }
          else if (year >= 1926) { birthEra = 'showa'; birthYear = year - 1925; }
          else { birthEra = 'taisho'; birthYear = year - 1911; }
        }
        
        setNewUserData({
          name: user.name,
          furigana: user.furigana || '',
          gender: user.gender || '',
          birthDate: user.birthDate || '',
          birthDateMode: 'wareki',
          birthEra: birthEra,
          birthYear: birthYear ? String(birthYear) : '',
          birthMonth: birthMonth ? String(birthMonth) : '',
          birthDay: birthDay ? String(birthDay) : '',
          conditions: user.conditions,
          stayDates: user.stayDates,
          fixedRooms: user.fixedRooms || {},
          bathType: user.bathType || '',
          medical: user.medical || { insulin: false, gastrostomy: false, oxygenTherapy: false },
          transport: user.transport || { pickupTime: '', dropoffTime: '', address: '', pickupMethod: '', wheelchairNeeded: false, note: '' },
          careManager: user.careManager || { officeName: '', staffName: '', phone: '', fax: '', mobile: '' }
        });
        // 利用日がある場合、最初の利用月にカレンダーを移動
        if (user.stayDates && user.stayDates.length > 0) {
          const firstDate = [...user.stayDates].sort()[0];
          const firstDateObj = parseLocalDate(firstDate);
          setCalendarMonth(getFirstDayOfMonth(firstDateObj));
        } else {
          setCalendarMonth(currentMonth);
        }
        setNewUserOpen(true);
        setSelectionStart(null);
      };

      const toggleCondition = (key) => {
        setNewUserData(prev => {
          const has = prev.conditions.includes(key);
          return {
            ...prev,
            conditions: has ? prev.conditions.filter(k => k !== key) : [...prev.conditions, key]
          };
        });
      };

      const handleDateClick = (dateStr) => {
        // 既に選択済みの日付をクリックした場合は削除
        if (newUserData.stayDates.includes(dateStr)) {
          setNewUserData(prev => ({
            ...prev,
            stayDates: prev.stayDates.filter(d => d !== dateStr)
          }));
          setSelectionStart(null); // 範囲選択もリセット
          return;
        }
        
        if (!selectionStart) {
          setSelectionStart(dateStr);
        } else {
          const range = getDatesInRange(selectionStart, dateStr);
          setNewUserData(prev => {
            const uniqueDates = Array.from(new Set([...prev.stayDates, ...range])).sort();
            return { ...prev, stayDates: uniqueDates };
          });
          setSelectionStart(null);
        }
      };

      const clearSelectedDates = () => {
        setNewUserData(prev => ({ ...prev, stayDates: [] }));
        setSelectionStart(null);
      };

      const deleteUser = (id) => {
        const user = users.find(u => u.id === id);
        if (!user) return;
        
        // 過去に利用記録があるかチェック
        const hasAllocations = Object.values(allocations).some(arr => arr.includes(id));
        
        if (hasAllocations) {
          // 利用記録がある場合はアーカイブ（非表示）にする
          if(window.confirm('この利用者をリストから非表示にしますか？\n（カレンダー上の過去の利用記録は残ります）')) {
            const newUsers = users.map(u => u.id === id ? { ...u, isArchived: true } : u);
            if (isFirebaseEnabled && database) {
              database.ref('data/' + STORAGE_KEY_USERS).set(newUsers);
            } else {
              setUsers(newUsers);
            }
          }
        } else {
          // 利用記録がない場合は完全削除
          if(window.confirm('この利用者を削除しますか？')) {
            const newUsers = users.filter(u => u.id !== id);
            if (isFirebaseEnabled && database) {
              database.ref('data/' + STORAGE_KEY_USERS).set(newUsers);
            } else {
              setUsers(newUsers);
            }
          }
        }
      };

      // 全利用者のスケジュールを再計算
      const recalculateAllSchedules = () => {
        if(!window.confirm('全利用者の入浴・リネンスケジュールを再計算しますか？\n（手動で変更した入浴予定もリセットされます）')) {
          return;
        }
        
        const updatedUsers = users.map(user => ({
          ...user,
          schedule: calculateInitialSchedule(user.stayDates, user.bathType || '')
        }));
        
        if (isFirebaseEnabled && database) {
          database.ref('data/' + STORAGE_KEY_USERS).set(updatedUsers);
        } else {
          setUsers(updatedUsers);
        }
        alert('全利用者のスケジュールを再計算しました！');
      };

      // 全データ再計算（部屋割り＋入浴スケジュール）
      const recalculateAllData = () => {
        if(!window.confirm('全利用者の部屋割りと入浴スケジュールを再計算しますか？\n\n・手動で変更した部屋割りはリセットされます\n・手動で変更した入浴予定もリセットされます')) {
          return;
        }
        
        // 1. 入浴スケジュールを再計算
        const updatedUsers = users.map(user => ({
          ...user,
          schedule: calculateInitialSchedule(user.stayDates, user.bathType || '')
        }));
        
        // 2. 部屋割りを全て再計算
        // 優先度順にソート（部屋固定 → 利用日数長い順 → 条件優先度）
        const sortedUsers = [...updatedUsers].filter(u => !u.isArchived && u.stayDates.length > 0).sort((a, b) => {
          // 部屋固定は最優先（fixedRoomsに登録がある場合）
          const aHasFixed = a.fixedRooms && Object.keys(a.fixedRooms).length > 0;
          const bHasFixed = b.fixedRooms && Object.keys(b.fixedRooms).length > 0;
          if (aHasFixed && !bHasFixed) return -1;
          if (!aHasFixed && bHasFixed) return 1;
          
          // 利用日数が長い順
          const daysA = a.stayDates.length;
          const daysB = b.stayDates.length;
          if (daysB !== daysA) return daysB - daysA;
          
          // 同じ日数なら条件優先度
          const getPriority = (user) => {
            if (user.conditions.includes('home_oxygen')) return 100;
            if (user.conditions.includes('high_fall_risk')) return 80;
            if (user.conditions.includes('is_new')) return 60;
            if (user.conditions.includes('near_toilet')) return 50;
            if (user.conditions.includes('low_fall_risk')) return 40;
            return 0;
          };
          return getPriority(b) - getPriority(a);
        });

        const newAllocations = {};

        sortedUsers.forEach(user => {
          const periods = getStayPeriods(user.stayDates);
          
          periods.forEach(period => {
            const periodKey = `${period[0]}_${period[period.length - 1]}`;
            const fixedRoomForPeriod = user.fixedRooms && user.fixedRooms[periodKey];
            
            // この期間が部屋固定されている場合
            if (fixedRoomForPeriod) {
              period.forEach(dateStr => {
                const key = `${dateStr}-${fixedRoomForPeriod}`;
                if (!newAllocations[key]) newAllocations[key] = [];
                newAllocations[key].push(user.id);
              });
              return; // 次の期間へ
            }
            
            // 固定されていない期間は自動割り当て
            let bestRoom = null;
            let bestScore = -9999;

            rooms.forEach(room => {
              let canUsePeriod = true;

              for (const dateStr of period) {
                const key = `${dateStr}-${room.id}`;
                const currentOccupants = newAllocations[key] || [];
                
                if (currentOccupants.length >= 2) {
                  canUsePeriod = false;
                  break;
                }
                
                if (currentOccupants.length === 1) {
                  const existingUserId = currentOccupants[0];
                  const existingUser = updatedUsers.find(u => u.id === existingUserId);
                  if (existingUser) {
                    const isCheckIn = !user.stayDates.includes(getPrevDay(dateStr));
                    const isCheckOut = !user.stayDates.includes(getNextDay(dateStr));
                    const existingIsCheckIn = !existingUser.stayDates.includes(getPrevDay(dateStr));
                    const existingIsCheckOut = !existingUser.stayDates.includes(getNextDay(dateStr));
                    const canShare = (existingIsCheckOut && isCheckIn) || (existingIsCheckIn && isCheckOut);
                    if (!canShare) {
                      canUsePeriod = false;
                      break;
                    }
                  }
                }
              }

              if (!canUsePeriod) return;

              let score = 0;
              
              if (user.conditions.includes('home_oxygen')) {
                if (room.features.includes('for_oxygen')) score += 1000; else score -= 500;
              } else {
                if (room.features.includes('for_oxygen')) score -= 20;
              }
              if (user.conditions.includes('high_fall_risk')) {
                if (room.features.includes('for_high_fall_risk')) score += 150;
                if (room.features.includes('near_toilet')) score += 80;
                if (room.features.includes('low_fall_risk')) score -= 50;
              }
              if (user.conditions.includes('is_new')) {
                if (room.features.includes('for_new')) score += 60;
                if (room.features.includes('near_toilet')) score += 30;
              }
              if (user.conditions.includes('near_toilet')) {
                if (room.features.includes('near_toilet')) score += 100; else score -= 50;
              }
              if (user.conditions.includes('low_fall_risk')) {
                if (room.features.includes('low_fall_risk')) score += 80;
              }

              if (score > bestScore) {
                bestScore = score;
                bestRoom = room;
              }
            });

            if (bestRoom) {
              period.forEach(dateStr => {
                const key = `${dateStr}-${bestRoom.id}`;
                newAllocations[key] = [...(newAllocations[key] || []), user.id];
              });
            } else {
              // フォールバック: 重複を許容して、重複が最も少ない部屋を選ぶ
              let fallbackRoom = null;
              let minConflicts = Infinity;
              let fallbackScore = -9999;
              
              rooms.forEach(room => {
                let conflictDays = 0;
                let hasFullDay = false;
                
                for (const dateStr of period) {
                  const key = `${dateStr}-${room.id}`;
                  const currentOccupants = newAllocations[key] || [];
                  
                  if (currentOccupants.length >= 2) {
                    hasFullDay = true;
                    break;
                  }
                  
                  if (currentOccupants.length === 1) {
                    const existingUserId = currentOccupants[0];
                    const existingUser = updatedUsers.find(u => u.id === existingUserId);
                    if (existingUser) {
                      const isCheckIn = !user.stayDates.includes(getPrevDay(dateStr));
                      const isCheckOut = !user.stayDates.includes(getNextDay(dateStr));
                      const existingIsCheckIn = !existingUser.stayDates.includes(getPrevDay(dateStr));
                      const existingIsCheckOut = !existingUser.stayDates.includes(getNextDay(dateStr));
                      const canShare = (existingIsCheckOut && isCheckIn) || (existingIsCheckIn && isCheckOut);
                      if (!canShare) {
                        conflictDays++;
                      }
                    }
                  }
                }
                
                if (hasFullDay) return;
                
                let score = 0;
                if (user.conditions.includes('home_oxygen')) {
                  if (room.features.includes('for_oxygen')) score += 1000; else score -= 500;
                }
                if (user.conditions.includes('high_fall_risk')) {
                  if (room.features.includes('for_high_fall_risk')) score += 150;
                }
                if (user.conditions.includes('near_toilet')) {
                  if (room.features.includes('near_toilet')) score += 100;
                }
                
                if (conflictDays < minConflicts || (conflictDays === minConflicts && score > fallbackScore)) {
                  minConflicts = conflictDays;
                  fallbackScore = score;
                  fallbackRoom = room;
                }
              });
              
              if (fallbackRoom) {
                period.forEach(dateStr => {
                  const key = `${dateStr}-${fallbackRoom.id}`;
                  newAllocations[key] = [...(newAllocations[key] || []), user.id];
                });
              }
            }
          });
        });

        if (isFirebaseEnabled && database) {
          const updates = {};
          updates[`data/${STORAGE_KEY_USERS}`] = updatedUsers;
          updates[`data/${STORAGE_KEY_ALLOCATIONS}`] = newAllocations;
          database.ref().update(updates).catch(e => {
            console.error('全データ再計算の更新に失敗', e);
          });
        } else {
          setUsers(updatedUsers);
          setAllocations(newAllocations);
        }
        alert('全データを再計算しました！\n（部屋割り＋入浴スケジュール）');
      };

      const handleMemoChange = (dateStr, roomId, value) => {
        const key = `${dateStr}-${roomId}`;
        if (isFirebaseEnabled && database) {
          // Firebaseが有効な場合は、特定のメモだけを更新する
          database.ref(`data/${STORAGE_KEY_MEMOS}/${key}`).set(value);
        } else {
          // ローカルモードでは、直接stateを更新する
          setMemos(prev => ({ ...prev, [key]: value }));
        }
      };

      const clearAllData = () => {
        if(window.confirm('全てのデータを削除して初期状態に戻しますか？')) {
          db.remove(STORAGE_KEY_USERS);
          db.remove(STORAGE_KEY_ALLOCATIONS); // ローカルはクリア
          db.remove(STORAGE_KEY_MEMOS); // ローカルはクリア
          if (isFirebaseEnabled && database) {
            // Firebase上のデータもクリア
            database.ref('data').set({
              [STORAGE_KEY_USERS]: generateSampleUsers(currentMonth),
              [STORAGE_KEY_ALLOCATIONS]: {},
              [STORAGE_KEY_MEMOS]: {},
            });
          }
          // stateを初期化（これはFirebaseのonSnapshotでも更新される）
          setUsers(generateSampleUsers(currentMonth)); setAllocations({}); setMemos({});
        }
      };

      const changeMonth = (direction) => {
        setCurrentMonth(prev => addMonths(prev, direction));
        setUseCustomRange(false); // 月を変更したらカスタム期間をリセット
      };

      const renderCalendarGrid = () => {
        const year = calendarMonth.getFullYear();
        const month = calendarMonth.getMonth();
        const firstDay = new Date(year, month, 1).getDay();
        const blanks = Array(firstDay).fill(null);
        const calendarDaysInMonth = getDaysInMonth(calendarMonth);
        const calendarDates = Array.from({ length: calendarDaysInMonth }, (_, i) => {
          return toDateStr(new Date(year, month, i + 1));
        });
        
        return (
          <div>
            {/* 月移動ボタン */}
            <div className="flex items-center justify-between mb-2">
              <button
                onClick={(e) => {
                  e.preventDefault();
                  setCalendarMonth(addMonths(calendarMonth, -1));
                }}
                className="p-1 hover:bg-gray-200 rounded text-gray-600"
              >
                <ChevronLeft size={16} />
              </button>
              <span className="text-sm font-bold text-gray-700">
                {calendarMonth.getFullYear()}年 {calendarMonth.getMonth() + 1}月
              </span>
              <button
                onClick={(e) => {
                  e.preventDefault();
                  setCalendarMonth(addMonths(calendarMonth, 1));
                }}
                className="p-1 hover:bg-gray-200 rounded text-gray-600"
              >
                <ChevronRight size={16} />
              </button>
            </div>
            
            <div className="grid grid-cols-7 gap-1 text-center">
              {['日','月','火','水','木','金','土'].map(d => (
                <div key={d} className={`text-xs font-bold p-1 ${d==='日'?'text-red-500':d==='土'?'text-blue-500':'text-gray-600'}`}>{d}</div>
              ))}
              {blanks.map((_, i) => <div key={`blank-${i}`} className="p-1"></div>)}
              {calendarDates.map(dateStr => {
                const dateObj = parseLocalDate(dateStr);
                const isSelected = newUserData.stayDates.includes(dateStr);
                const isStart = selectionStart === dateStr;
                const dayOfWeek = dateObj.getDay();
                const isSun = dayOfWeek === 0;
                const isSat = dayOfWeek === 6;
                return (
                  <button
                    key={dateStr}
                    type="button"
                    onClick={() => handleDateClick(dateStr)}
                    className={`
                      p-2 text-xs rounded border transition-colors relative
                      ${isSelected 
                        ? 'bg-blue-600 text-white border-blue-700 hover:bg-red-500 hover:border-red-600' 
                        : 'bg-white hover:bg-gray-100 border-gray-200'}
                      ${!isSelected && isSun ? 'text-red-500' : ''}
                      ${!isSelected && isSat ? 'text-blue-500' : ''}
                      ${isStart ? 'ring-2 ring-yellow-400 z-10' : ''}
                    `}
                    title={isSelected ? 'クリックで削除' : ''}
                  >
                    {dateObj.getDate()}
                    {isStart && <span className="absolute -top-1 -right-1 flex h-3 w-3"><span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-yellow-400 opacity-75"></span><span className="relative inline-flex rounded-full h-3 w-3 bg-yellow-500"></span></span>}
                  </button>
                );
              })}
            </div>
          </div>
        );
      };

      if (!isLoaded) {
        return <div className="min-h-screen flex items-center justify-center text-gray-500">データを読み込み中...</div>;
      }

      return (
        <>
        <div className="min-h-screen bg-gray-50 p-4 text-sm md:text-base font-sans print-p-0 print-bg-white">
          {/* 折りたたみ時のコンパクトヘッダー */}
          {headerCollapsed && (
            <div className="mb-2 bg-blue-600 text-white px-4 py-2 rounded shadow-sm flex justify-between items-center print-hidden">
              <div className="flex items-center gap-2">
                <button onClick={() => changeMonth(-1)} className="p-1 hover:bg-blue-500 rounded">
                  <ChevronLeft size={18}/>
                </button>
                <span className="font-bold">{currentMonth.getFullYear()}年{currentMonth.getMonth() + 1}月</span>
                <button onClick={() => changeMonth(1)} className="p-1 hover:bg-blue-500 rounded">
                  <ChevronRight size={18}/>
                </button>
                <button 
                  onClick={() => setHeaderCollapsed(false)}
                  className="ml-2 bg-white text-blue-600 px-3 py-1 rounded text-sm font-bold hover:bg-blue-50"
                >
                  ▼ 展開
                </button>
              </div>
              <span className="text-sm opacity-75">{APP_CONFIG.facilityName}</span>
            </div>
          )}
          
          {/* 通常のヘッダー */}
          {!headerCollapsed && (
          <header className="mb-4 bg-white p-4 rounded shadow-sm border-l-4 border-blue-600 flex flex-col md:flex-row justify-between items-center gap-4 print-hidden">
            <div>
              <div className="flex items-center gap-2">
                <h1 className="text-xl font-bold text-gray-800">{APP_CONFIG.facilityName} 部屋割表（月間）</h1>
                <button 
                  onClick={() => setHeaderCollapsed(true)}
                  className="bg-blue-500 hover:bg-blue-600 text-white text-sm px-3 py-1 rounded border-2 border-blue-600 font-bold shadow-sm"
                  title="ヘッダーを折りたたむ"
                >
                  ▲ 縮小
                </button>
              </div>
              <div className="flex items-center gap-4 mt-2">
                <div className="flex items-center gap-4 bg-gray-100 p-2 rounded-lg">
                  <button onClick={() => changeMonth(-1)} className="p-1 hover:bg-gray-200 rounded">
                    <ChevronLeft size={20}/>
                  </button>
                  <span className="font-bold text-gray-700 flex items-center gap-2 text-lg w-40 justify-center">
                    <CalendarIcon size={20}/>
                    {currentMonth.getFullYear()}年 {currentMonth.getMonth() + 1}月
                  </span>
                  <button onClick={() => changeMonth(1)} className="p-1 hover:bg-gray-200 rounded">
                    <ChevronRight size={20}/>
                  </button>
                </div>
                
                {/* 利用者検索 */}
                <div className="relative">
                  <input
                    type="text"
                    placeholder="🔍 利用者検索..."
                    value={userSearchQuery}
                    onChange={(e) => setUserSearchQuery(e.target.value)}
                    className="w-48 p-2 pl-3 pr-8 border rounded text-sm focus:outline-none focus:ring-2 focus:ring-blue-300 bg-white"
                  />
                  {userSearchQuery && (
                    <button
                      onClick={() => setUserSearchQuery('')}
                      className="absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600 text-lg font-bold"
                    >
                      ×
                    </button>
                  )}
                </div>

                {/* 期間選択 */}
                <div className="flex items-center gap-2 ml-4 bg-white border rounded p-2">
                  <span className="text-xs text-gray-500">📅期間:</span>
                  <input
                    type="date"
                    value={displayStartDate}
                    onChange={(e) => {
                      setDisplayStartDate(e.target.value);
                      if (e.target.value && displayEndDate) {
                        setUseCustomRange(true);
                      }
                    }}
                    className="text-sm p-1 border rounded w-32"
                  />
                  <span className="text-gray-400">～</span>
                  <input
                    type="date"
                    value={displayEndDate}
                    onChange={(e) => {
                      setDisplayEndDate(e.target.value);
                      if (displayStartDate && e.target.value) {
                        setUseCustomRange(true);
                      }
                    }}
                    className="text-sm p-1 border rounded w-32"
                  />
                  {useCustomRange && (
                    <button
                      onClick={() => {
                        setUseCustomRange(false);
                        setDisplayStartDate('');
                        setDisplayEndDate('');
                      }}
                      className="text-xs bg-gray-200 hover:bg-gray-300 px-2 py-1 rounded text-gray-600"
                    >
                      月表示に戻す
                    </button>
                  )}
                </div>
              </div>
            </div>
            <div className="flex gap-2 items-center flex-wrap justify-end">
              {/* バックアップ警告 */}
              {(() => {
                const daysSinceBackup = lastBackup 
                  ? Math.floor((new Date() - lastBackup) / (1000 * 60 * 60 * 24))
                  : null;
                const needsBackup = daysSinceBackup === null || daysSinceBackup >= 7;
                
                return (
                  <div className={`text-xs mr-2 flex items-center gap-1 ${needsBackup ? 'text-red-500 font-bold' : 'text-gray-400'}`}>
                    <Save size={14}/>
                    {lastBackup ? (
                      needsBackup ? (
                        <span>⚠️ {daysSinceBackup}日前にバックアップ</span>
                      ) : (
                        <span>最終バックアップ: {daysSinceBackup === 0 ? '今日' : `${daysSinceBackup}日前`}</span>
                      )
                    ) : (
                      <span>⚠️ バックアップ未実施</span>
                    )}
                  </div>
                );
              })()}
              <button 
                onClick={exportData}
                className={`flex items-center gap-1 text-white px-3 py-2 rounded font-bold shadow transition-colors text-sm ${
                  (!lastBackup || (new Date() - lastBackup) / (1000 * 60 * 60 * 24) >= 7)
                    ? 'bg-red-500 hover:bg-red-600 animate-pulse'
                    : 'bg-green-600 hover:bg-green-700'
                }`}
                title="バックアップ"
              >
                <Download size={16} />
                保存
              </button>
              <button 
                onClick={() => fileInputRef.current?.click()}
                className="flex items-center gap-1 bg-yellow-600 hover:bg-yellow-700 text-white px-3 py-2 rounded font-bold shadow transition-colors text-sm"
                title="復元"
              >
                <Upload size={16} />
                復元
              </button>
              <input
                ref={fileInputRef}
                type="file"
                accept=".json"
                onChange={importData}
                className="hidden"
              />
              <button 
                onClick={recalculateAllData}
                className="flex items-center gap-1 bg-orange-600 hover:bg-orange-700 text-white px-3 py-2 rounded font-bold shadow transition-colors text-sm"
                title="全利用者の部屋割り＋入浴スケジュールを再計算"
              >
                🔄 すべて再計算
              </button>
              <button 
                onClick={recalculateAllSchedules}
                className="flex items-center gap-1 bg-purple-600 hover:bg-purple-700 text-white px-3 py-2 rounded font-bold shadow transition-colors text-sm"
                title="入浴・リネンスケジュールのみ再計算（部屋割りは変更しない）"
              >
                🛁🛏️ 入浴・リネンのみ再計算
              </button>
              <button 
                onClick={() => window.print()}
                className="flex items-center gap-2 bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded font-bold shadow transition-colors"
              >
                <Printer size={18} />
                印刷
              </button>
              <button 
                onClick={() => setShowSettings(true)}
                className="flex items-center gap-1 bg-gray-500 hover:bg-gray-600 text-white px-3 py-2 rounded font-bold shadow transition-colors text-sm"
                title="設定"
              >
                <Settings size={16} />
              </button>
              <button 
                onClick={() => setShowLogoutConfirm(true)}
                className="flex items-center gap-1 bg-red-500 hover:bg-red-600 text-white px-3 py-2 rounded font-bold shadow transition-colors text-sm"
                title="ログアウト"
              >
                <LogOut size={16} />
              </button>
            </div>
          </header>
          )}

          {/* ログアウト確認モーダル */}
          {showLogoutConfirm && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
              <div className="bg-white rounded-lg shadow-xl p-6 w-96 max-w-[90vw]">
                <h3 className="font-bold text-gray-800 mb-3 text-lg">ログアウト</h3>
                
                {(() => {
                  const daysSinceBackup = lastBackup 
                    ? Math.floor((new Date() - lastBackup) / (1000 * 60 * 60 * 24))
                    : null;
                  const needsBackup = daysSinceBackup === null || daysSinceBackup >= 7;
                  
                  return needsBackup ? (
                    <div className="mb-4">
                      <div className="bg-red-50 border border-red-200 rounded p-3 mb-3">
                        <p className="text-red-600 font-bold text-sm">
                          ⚠️ {lastBackup ? `${daysSinceBackup}日間バックアップしていません` : 'まだバックアップしていません'}
                        </p>
                        <p className="text-red-500 text-xs mt-1">
                          ログアウト前にバックアップをおすすめします
                        </p>
                      </div>
                      <button
                        onClick={() => {
                          exportData();
                        }}
                        className="w-full bg-green-600 hover:bg-green-700 text-white py-2 rounded font-bold mb-2 flex items-center justify-center gap-2"
                      >
                        <Download size={16} />
                        今すぐバックアップ
                      </button>
                    </div>
                  ) : (
                    <p className="text-gray-600 mb-4 text-sm">
                      ログアウトしますか？<br/>
                      <span className="text-green-600">✓ 最終バックアップ: {daysSinceBackup === 0 ? '今日' : `${daysSinceBackup}日前`}</span>
                    </p>
                  );
                })()}
                
                <div className="flex gap-2">
                  <button
                    onClick={() => setShowLogoutConfirm(false)}
                    className="flex-1 bg-gray-200 hover:bg-gray-300 text-gray-700 py-2 rounded font-bold"
                  >
                    キャンセル
                  </button>
                  <button
                    onClick={() => {
                      setShowLogoutConfirm(false);
                      onLogout();
                    }}
                    className="flex-1 bg-red-500 hover:bg-red-600 text-white py-2 rounded font-bold"
                  >
                    ログアウト
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* 設定モーダル */}
          {showSettings && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
              <div className="bg-white rounded-lg shadow-xl p-6 w-[450px] max-w-[90vw] max-h-[90vh] overflow-y-auto">
                <div className="flex justify-between items-center mb-4">
                  <h2 className="text-lg font-bold text-gray-800 flex items-center gap-2">
                    <Settings size={20} />
                    設定
                  </h2>
                  <button 
                    onClick={() => {
                      setShowSettings(false);
                      setSettingsError('');
                      setSettingsSuccess('');
                      setArchiveYear('');
                      setArchiveStats(null);
                    }}
                    className="text-gray-400 hover:text-gray-600 text-2xl leading-none"
                  >&times;</button>
                </div>

                <div className="border-b pb-4 mb-4">
                  <h3 className="font-bold text-gray-700 mb-3">🔑 パスワード変更</h3>
                  <div className="space-y-3">
                    <div>
                      <label className="block text-sm text-gray-600 mb-1">現在のパスワード</label>
                      <input
                        type="password"
                        value={currentPassword}
                        onChange={(e) => setCurrentPassword(e.target.value)}
                        className="w-full p-2 border rounded text-sm"
                        placeholder="現在のパスワード"
                      />
                    </div>
                    <div>
                      <label className="block text-sm text-gray-600 mb-1">新しいパスワード</label>
                      <input
                        type="password"
                        value={newPassword}
                        onChange={(e) => setNewPassword(e.target.value)}
                        className="w-full p-2 border rounded text-sm"
                        placeholder="新しいパスワード"
                      />
                    </div>
                    <div>
                      <label className="block text-sm text-gray-600 mb-1">新しいパスワード（確認）</label>
                      <input
                        type="password"
                        value={confirmPassword}
                        onChange={(e) => setConfirmPassword(e.target.value)}
                        className="w-full p-2 border rounded text-sm"
                        placeholder="新しいパスワードを再入力"
                      />
                    </div>
                    {settingsError && (
                      <div className="text-red-500 text-sm bg-red-50 p-2 rounded">{settingsError}</div>
                    )}
                    {settingsSuccess && (
                      <div className="text-green-600 text-sm bg-green-50 p-2 rounded">{settingsSuccess}</div>
                    )}
                    <button
                      onClick={() => {
                        setSettingsError('');
                        setSettingsSuccess('');
                        
                        if (!currentPassword || !newPassword || !confirmPassword) {
                          setSettingsError('すべての項目を入力してください');
                          return;
                        }
                        if (currentPassword !== getPassword()) {
                          setSettingsError('現在のパスワードが正しくありません');
                          return;
                        }
                        if (newPassword.length < 4) {
                          setSettingsError('新しいパスワードは4文字以上にしてください');
                          return;
                        }
                        if (newPassword !== confirmPassword) {
                          setSettingsError('新しいパスワードが一致しません');
                          return;
                        }
                        
                        setPassword(newPassword);
                        setCurrentPassword('');
                        setNewPassword('');
                        setConfirmPassword('');
                        setSettingsSuccess('パスワードを変更しました');
                      }}
                      className="w-full bg-blue-600 hover:bg-blue-700 text-white py-2 rounded font-bold"
                    >
                      パスワードを変更
                    </button>
                  </div>
                </div>

                <div className="text-xs text-gray-400">
                  <p>※パスワードはこのブラウザに保存されます</p>
                  <p>※初期パスワード: keijuen2025</p>
                </div>

                {/* データ整理セクション */}
                <div className="border-t pt-4 mt-4">
                  <h3 className="font-bold text-gray-700 mb-3">📦 データ整理（年別アーカイブ）</h3>
                  <p className="text-xs text-gray-500 mb-3">
                    古い年のデータをJSONファイルに保存して、アプリから削除します。<br/>
                    削除後もJSONファイルをExcel等で開けば確認できます。
                  </p>
                  
                  {getDataYears().length > 0 ? (
                    <div className="space-y-3">
                      <div>
                        <label className="block text-sm text-gray-600 mb-1">アーカイブする年を選択</label>
                        <select
                          value={archiveYear}
                          onChange={(e) => {
                            setArchiveYear(e.target.value);
                            if (e.target.value) {
                              setArchiveStats(calculateArchiveStats(e.target.value));
                            } else {
                              setArchiveStats(null);
                            }
                          }}
                          className="w-full p-2 border rounded text-sm"
                        >
                          <option value="">選択してください</option>
                          {getDataYears().map(year => (
                            <option key={year} value={year}>{year}年</option>
                          ))}
                        </select>
                      </div>
                      
                      {archiveStats && (
                        <div className="bg-gray-50 p-3 rounded text-sm">
                          <p className="font-bold text-gray-700 mb-2">📊 {archiveYear}年のデータ:</p>
                          <ul className="text-gray-600 space-y-1">
                            <li>・利用日数: {archiveStats.stayDateCount}件</li>
                            <li>・部屋割り: {archiveStats.allocationCount}件</li>
                            <li>・メモ: {archiveStats.memoCount}件</li>
                          </ul>
                        </div>
                      )}
                      
                      <div className="flex gap-2">
                        <button
                          onClick={() => archiveYear && exportYearData(archiveYear)}
                          disabled={!archiveYear}
                          className="flex-1 bg-green-600 hover:bg-green-700 disabled:bg-gray-300 text-white py-2 rounded font-bold text-sm"
                        >
                          📥 {archiveYear || '?'}年を保存のみ
                        </button>
                        <button
                          onClick={() => archiveYear && setShowArchiveConfirm(true)}
                          disabled={!archiveYear}
                          className="flex-1 bg-red-500 hover:bg-red-600 disabled:bg-gray-300 text-white py-2 rounded font-bold text-sm"
                        >
                          🗑️ 保存して削除
                        </button>
                      </div>
                    </div>
                  ) : (
                    <p className="text-gray-400 text-sm">アーカイブ対象のデータがありません</p>
                  )}
                </div>
              </div>
            </div>
          )}

          {/* アーカイブ確認モーダル */}
          {showArchiveConfirm && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[60]">
              <div className="bg-white rounded-lg shadow-xl p-6 w-96 max-w-[90vw]">
                <h3 className="font-bold text-red-600 mb-3 text-lg">⚠️ データ削除の確認</h3>
                <div className="bg-red-50 border border-red-200 rounded p-3 mb-4">
                  <p className="text-red-700 text-sm font-bold mb-2">
                    {archiveYear}年のデータを削除します
                  </p>
                  <p className="text-red-600 text-xs">
                    ・まずJSONファイルがダウンロードされます<br/>
                    ・その後、アプリからデータが削除されます<br/>
                    ・削除後は復元ボタンでJSONを読み込めば戻せます
                  </p>
                </div>
                <div className="flex gap-2">
                  <button
                    onClick={() => setShowArchiveConfirm(false)}
                    className="flex-1 bg-gray-200 hover:bg-gray-300 text-gray-700 py-2 rounded font-bold"
                  >
                    キャンセル
                  </button>
                  <button
                    onClick={() => executeArchive(archiveYear)}
                    className="flex-1 bg-red-500 hover:bg-red-600 text-white py-2 rounded font-bold"
                  >
                    削除する
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* 部屋条件編集モーダル */}
          {showRoomEditor && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
              <div className="bg-white rounded-lg shadow-xl p-6 w-[500px] max-w-[95vw] max-h-[90vh] overflow-y-auto">
                <div className="flex justify-between items-center mb-4">
                  <h3 className="font-bold text-gray-800 text-lg">🏠 部屋条件の編集</h3>
                  <button 
                    onClick={() => setShowRoomEditor(false)} 
                    className="text-gray-400 hover:text-gray-600 text-2xl leading-none"
                  >&times;</button>
                </div>
                
                <div className="space-y-3">
                  {editingRooms.map((room, index) => (
                    <div key={room.id} className="p-3 bg-gray-50 rounded border border-gray-200">
                      <div className="flex items-center gap-2 mb-2">
                        <span className="font-bold text-gray-700 text-lg">{room.name}号室</span>
                      </div>
                      <div className="flex flex-wrap gap-2">
                        {ROOM_FEATURES.map(feature => (
                          <label key={feature.key} className="flex items-center gap-1 cursor-pointer bg-white px-2 py-1 rounded border hover:bg-blue-50">
                            <input 
                              type="checkbox" 
                              checked={room.features.includes(feature.key)}
                              onChange={(e) => {
                                const newRooms = [...editingRooms];
                                // 部屋オブジェクトを複製して直接変更を防ぐ
                                newRooms[index] = { ...newRooms[index] };
                                if (e.target.checked) {
                                  newRooms[index].features = [...room.features, feature.key];
                                } else {
                                  newRooms[index].features = room.features.filter(f => f !== feature.key);
                                }
                                // ラベルを自動生成
                                const labels = newRooms[index].features.map(f => 
                                  ROOM_FEATURES.find(rf => rf.key === f)?.label || f
                                );
                                newRooms[index].label = labels.length > 0 ? labels.join('・') : '通常';
                                setEditingRooms(newRooms);
                              }}
                              className="rounded text-blue-600"
                            />
                            <span className="text-xs text-gray-700">{feature.label}</span>
                          </label>
                        ))}
                      </div>
                      <div className="mt-2 text-xs text-gray-500">
                        現在の設定: <span className="font-bold text-gray-700">{room.label || '通常'}</span>
                      </div>
                    </div>
                  ))}
                </div>
                
                <div className="flex gap-2 mt-4">
                  <button
                    onClick={() => setShowRoomEditor(false)}
                    className="flex-1 bg-gray-200 hover:bg-gray-300 text-gray-700 py-2 rounded font-bold"
                  >
                    キャンセル
                  </button>
                  <button
                    onClick={() => {
                      if (isFirebaseEnabled && database) {
                        database.ref('data/' + STORAGE_KEY_ROOMS).set(editingRooms);
                      } else {
                        setRooms(editingRooms);
                      }
                      setShowRoomEditor(false);
                    }}
                    className="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 rounded font-bold"
                  >
                    保存
                  </button>
                </div>
                
                <div className="mt-4 text-center">
                  <button
                    onClick={() => {
                      if (window.confirm('部屋条件を初期状態に戻しますか？')) {
                        setEditingRooms(JSON.parse(JSON.stringify(INITIAL_ROOMS)));
                      }
                    }}
                    className="text-xs text-gray-400 hover:text-red-500 underline"
                  >
                    初期状態に戻す
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* 食事伝票モーダル */}
          {showMealTicketModal && editingMealTicket && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
              <div className="bg-white rounded-lg shadow-xl p-6 w-[700px] max-w-[95vw] max-h-[90vh] overflow-y-auto">
                <div className="flex justify-between items-center mb-4">
                  <h3 className="font-bold text-gray-800 text-lg">🍽️ 食事指示箋</h3>
                  <button 
                    onClick={() => {
                      setShowMealTicketModal(false);
                      setEditingMealTicket(null);
                    }} 
                    className="text-gray-400 hover:text-gray-600 text-2xl leading-none"
                  >&times;</button>
                </div>
                
                {/* 前回の伝票を複写ボタン & 削除ボタン */}
                <div className="mb-4 flex justify-between items-center">
                  <button
                    onClick={() => {
                      // 同じユーザーの過去の伝票を探す（現在の伝票は除く）
                      const currentKey = `${editingMealTicket.userId}_${editingMealTicket.startDate}_${editingMealTicket.endDate}`;
                      const userTickets = Object.entries(mealTickets)
                        .filter(([key, ticket]) => 
                          ticket.userId === editingMealTicket.userId && key !== currentKey
                        )
                        .map(([key, ticket]) => ({ key, ticket, startDate: ticket.startDate }))
                        .sort((a, b) => b.startDate.localeCompare(a.startDate)); // 新しい順
                      
                      if (userTickets.length === 0) {
                        alert('この利用者の過去の伝票がありません');
                        return;
                      }
                      
                      const lastTicket = userTickets[0].ticket;
                      setEditingMealTicket({
                        ...editingMealTicket,
                        // 日付とユーザーIDは現在のまま
                        unit: lastTicket.unit || '樹',
                        startMeal: lastTicket.startMeal || '',
                        endMeal: lastTicket.endMeal || '',
                        category: lastTicket.category || '',
                        reason: lastTicket.reason || '',
                        foodType: lastTicket.foodType || '',
                        diabetesKcal: lastTicket.diabetesKcal || '',
                        mainDish: lastTicket.mainDish || '',
                        mainDishOther: lastTicket.mainDishOther || '',
                        sideDish: lastTicket.sideDish || '',
                        sideDishOther: lastTicket.sideDishOther || '',
                        drink: lastTicket.drink || '',
                        snack: lastTicket.snack || '',
                        memo: lastTicket.memo || ''
                      });
                      alert(`${lastTicket.startDate}〜の伝票内容を複写しました`);
                    }}
                    className="w-1/2 bg-orange-500 hover:bg-orange-600 text-white py-2 rounded-lg font-bold shadow-md flex items-center justify-center gap-2"
                  >
                    📋 前回の伝票を複写
                  </button>
                  
                  {/* 削除ボタン（保存済みの場合のみ表示） */}
                  {(() => {
                    const ticketKey = `${editingMealTicket.userId}_${editingMealTicket.startDate}_${editingMealTicket.endDate}`;
                    const exists = mealTickets[ticketKey];
                    if (!exists) return null;
                    return (
                      <button
                        onClick={() => {
                          if (window.confirm(`この伝票（${editingMealTicket.startDate}〜${editingMealTicket.endDate}）を削除しますか？`)) {
                            setMealTickets(prev => {
                              const newTickets = { ...prev };
                              delete newTickets[ticketKey];
                              return newTickets;
                            });
                            setShowMealTicketModal(false);
                            setEditingMealTicket(null);
                            alert('伝票を削除しました');
                          }
                        }}
                        className="w-1/4 bg-red-100 hover:bg-red-200 text-red-600 py-2 rounded font-bold border border-red-300 text-sm"
                      >
                        🗑️ 削除
                      </button>
                    );
                  })()}
                </div>
                
                {/* 利用期間選択 */}
                <div className="bg-blue-50 p-3 rounded border border-blue-200 mb-4">
                  <label className="text-sm font-bold text-blue-700 block mb-2">📅 利用期間を選択</label>
                  <select
                    value={`${editingMealTicket.startDate}_${editingMealTicket.endDate}`}
                    onChange={(e) => {
                      const [start, end] = e.target.value.split('_');
                      const ticketKey = `${editingMealTicket.userId}_${start}_${end}`;
                      const existingTicket = mealTickets[ticketKey];
                      if (existingTicket) {
                        setEditingMealTicket(existingTicket);
                      } else {
                        setEditingMealTicket({
                          ...editingMealTicket,
                          startDate: start,
                          endDate: end,
                          unit: '樹',
                          startMeal: '',
                          endMeal: '',
                          category: '',
                          reason: '',
                          foodType: '',
                          diabetesKcal: '',
                          mainDish: '',
                          mainDishOther: '',
                          sideDish: '',
                          sideDishOther: '',
                          drink: '',
                          snack: '',
                          memo: ''
                        });
                      }
                    }}
                    className="w-full p-2 border rounded text-sm bg-white"
                  >
                    {(() => {
                      const user = users.find(u => u.id === editingMealTicket.userId);
                      if (!user || !user.stayDates || user.stayDates.length === 0) return null;
                      
                      // 当月の利用期間のみフィルタリング
                      const monthStr = `${currentMonth.getFullYear()}-${String(currentMonth.getMonth() + 1).padStart(2, '0')}`;
                      const periods = getStayPeriods(user.stayDates);
                      const currentMonthPeriods = periods.filter(period => {
                        const periodStart = period[0];
                        return periodStart.startsWith(monthStr);
                      });
                      
                      if (currentMonthPeriods.length === 0) {
                        // 当月に期間がない場合は全期間を表示
                        return periods.map((period, index) => {
                          const start = period[0];
                          const end = period[period.length - 1];
                          const ticketKey = `${user.id}_${start}_${end}`;
                          const hasTicket = mealTickets[ticketKey];
                          return (
                            <option key={index} value={`${start}_${end}`}>
                              {start} ～ {end} {hasTicket ? '✓作成済み' : '（未作成）'}
                            </option>
                          );
                        });
                      }
                      
                      return currentMonthPeriods.map((period, index) => {
                        const start = period[0];
                        const end = period[period.length - 1];
                        const ticketKey = `${user.id}_${start}_${end}`;
                        const hasTicket = mealTickets[ticketKey];
                        return (
                          <option key={index} value={`${start}_${end}`}>
                            {start} ～ {end} {hasTicket ? '✓作成済み' : '（未作成）'}
                          </option>
                        );
                      });
                    })()}
                  </select>
                  <p className="text-xs text-blue-600 mt-1">
                    ※ {currentMonth.getFullYear()}年{currentMonth.getMonth() + 1}月の利用期間を表示中
                  </p>
                </div>
                
                {/* 基本情報（読み取り専用） */}
                <div className="bg-gray-50 p-3 rounded border mb-4">
                  <div className="grid grid-cols-2 gap-2 text-sm">
                    <div><span className="text-gray-500">利用者:</span> <span className="font-bold">{users.find(u => u.id === editingMealTicket.userId)?.name}</span></div>
                    <div><span className="text-gray-500">フリガナ:</span> <span className="font-bold">{users.find(u => u.id === editingMealTicket.userId)?.furigana}</span></div>
                    <div><span className="text-gray-500">開始日:</span> <span className="font-bold">{editingMealTicket.startDate}</span></div>
                    <div><span className="text-gray-500">終了日:</span> <span className="font-bold">{editingMealTicket.endDate}</span></div>
                  </div>
                </div>

                {/* ユニット入力 */}
                <div className="mb-4">
                  <label className="text-sm font-bold text-gray-600 block mb-1">ユニット</label>
                  <input
                    type="text"
                    placeholder="例: 1F-A"
                    value={editingMealTicket.unit || ''}
                    onChange={(e) => setEditingMealTicket({...editingMealTicket, unit: e.target.value})}
                    className="w-full p-2 border rounded text-sm"
                  />
                </div>

                {/* 開始・終了の食事 */}
                <div className="grid grid-cols-2 gap-4 mb-4">
                  <div>
                    <label className="text-sm font-bold text-gray-600 block mb-1">開始日 令和 {editingMealTicket.startDate ? (() => {
                      const d = parseLocalDate(editingMealTicket.startDate);
                      return `${d.getFullYear() - 2018}年${d.getMonth()+1}月${d.getDate()}日`;
                    })() : ''}</label>
                    <select
                      value={editingMealTicket.startMeal || ''}
                      onChange={(e) => setEditingMealTicket({...editingMealTicket, startMeal: e.target.value})}
                      className="w-full p-2 border rounded text-sm"
                    >
                      <option value="">選択してください</option>
                      {MEAL_TIMING.map(t => (
                        <option key={t.key} value={t.key}>{t.label}</option>
                      ))}
                    </select>
                    <span className="text-xs text-gray-500">から</span>
                  </div>
                  <div>
                    <label className="text-sm font-bold text-gray-600 block mb-1">終了日 令和 {editingMealTicket.endDate ? (() => {
                      const d = parseLocalDate(editingMealTicket.endDate);
                      return `${d.getFullYear() - 2018}年${d.getMonth()+1}月${d.getDate()}日`;
                    })() : ''}</label>
                    <select
                      value={editingMealTicket.endMeal || ''}
                      onChange={(e) => setEditingMealTicket({...editingMealTicket, endMeal: e.target.value})}
                      className="w-full p-2 border rounded text-sm"
                    >
                      <option value="">選択してください</option>
                      {MEAL_TIMING.map(t => (
                        <option key={t.key} value={t.key}>{t.label}</option>
                      ))}
                    </select>
                    <span className="text-xs text-gray-500">まで</span>
                  </div>
                </div>

                {/* 区分・理由 */}
                <div className="grid grid-cols-2 gap-4 mb-4">
                  <div>
                    <label className="text-sm font-bold text-gray-600 block mb-1">区分</label>
                    <select
                      value={editingMealTicket.category || ''}
                      onChange={(e) => setEditingMealTicket({...editingMealTicket, category: e.target.value})}
                      className="w-full p-2 border rounded text-sm"
                    >
                      <option value="">選択してください</option>
                      {MEAL_CATEGORY.map(c => (
                        <option key={c.key} value={c.key}>{c.label}</option>
                      ))}
                    </select>
                  </div>
                  <div>
                    <label className="text-sm font-bold text-gray-600 block mb-1">理由</label>
                    <select
                      value={editingMealTicket.reason || ''}
                      onChange={(e) => setEditingMealTicket({...editingMealTicket, reason: e.target.value})}
                      className="w-full p-2 border rounded text-sm"
                    >
                      <option value="">選択してください</option>
                      {MEAL_REASON.map(r => (
                        <option key={r.key} value={r.key}>{r.label}</option>
                      ))}
                    </select>
                  </div>
                </div>

                {/* 食種 */}
                <div className="mb-4">
                  <label className="text-sm font-bold text-gray-600 block mb-1">食種</label>
                  <div className="flex flex-wrap gap-2">
                    {MEAL_FOOD_TYPES.map(f => (
                      <label key={f.key} className={`flex items-center gap-1 cursor-pointer px-2 py-1 rounded border text-xs
                        ${editingMealTicket.foodType === f.key ? 'bg-blue-100 border-blue-400' : 'bg-white hover:bg-gray-50'}`}>
                        <input 
                          type="radio" 
                          name="foodType"
                          checked={editingMealTicket.foodType === f.key}
                          onChange={() => setEditingMealTicket({...editingMealTicket, foodType: f.key})}
                          className="hidden"
                        />
                        <span>{f.label}</span>
                      </label>
                    ))}
                  </div>
                  {editingMealTicket.foodType === 'diabetes' && (
                    <div className="mt-2">
                      <input
                        type="text"
                        placeholder="kcal入力"
                        value={editingMealTicket.diabetesKcal || ''}
                        onChange={(e) => setEditingMealTicket({...editingMealTicket, diabetesKcal: e.target.value})}
                        className="p-1 border rounded text-sm w-24"
                      />
                      <span className="text-xs text-gray-500 ml-1">kcal</span>
                    </div>
                  )}
                </div>

                {/* 主食 */}
                <div className="mb-4">
                  <label className="text-sm font-bold text-gray-600 block mb-1">主食</label>
                  <div className="flex flex-wrap gap-2">
                    {MEAL_MAIN_DISH.map(m => (
                      <label key={m.key} className={`flex items-center gap-1 cursor-pointer px-2 py-1 rounded border text-xs
                        ${editingMealTicket.mainDish === m.key ? 'bg-blue-100 border-blue-400' : 'bg-white hover:bg-gray-50'}`}>
                        <input 
                          type="radio" 
                          name="mainDish"
                          checked={editingMealTicket.mainDish === m.key}
                          onChange={() => setEditingMealTicket({...editingMealTicket, mainDish: m.key})}
                          className="hidden"
                        />
                        <span>{m.label}</span>
                      </label>
                    ))}
                  </div>
                  {editingMealTicket.mainDish === 'other' && (
                    <input
                      type="text"
                      placeholder="その他の主食"
                      value={editingMealTicket.mainDishOther || ''}
                      onChange={(e) => setEditingMealTicket({...editingMealTicket, mainDishOther: e.target.value})}
                      className="mt-2 p-1 border rounded text-sm w-full"
                    />
                  )}
                </div>

                {/* 副食 */}
                <div className="mb-4">
                  <label className="text-sm font-bold text-gray-600 block mb-1">副食</label>
                  <div className="flex flex-wrap gap-2">
                    {MEAL_SIDE_DISH.map(s => (
                      <label key={s.key} className={`flex items-center gap-1 cursor-pointer px-2 py-1 rounded border text-xs
                        ${editingMealTicket.sideDish === s.key ? 'bg-blue-100 border-blue-400' : 'bg-white hover:bg-gray-50'}`}>
                        <input 
                          type="radio" 
                          name="sideDish"
                          checked={editingMealTicket.sideDish === s.key}
                          onChange={() => setEditingMealTicket({...editingMealTicket, sideDish: s.key})}
                          className="hidden"
                        />
                        <span>{s.label}</span>
                      </label>
                    ))}
                  </div>
                  {editingMealTicket.sideDish === 'other' && (
                    <input
                      type="text"
                      placeholder="その他の副食"
                      value={editingMealTicket.sideDishOther || ''}
                      onChange={(e) => setEditingMealTicket({...editingMealTicket, sideDishOther: e.target.value})}
                      className="mt-2 p-1 border rounded text-sm w-full"
                    />
                  )}
                </div>

                {/* 飲み物・間食 */}
                <div className="grid grid-cols-2 gap-4 mb-4">
                  <div>
                    <label className="text-sm font-bold text-gray-600 block mb-1">飲み物</label>
                    <div className="flex gap-2">
                      {MEAL_DRINK.map(d => (
                        <label key={d.key} className={`flex items-center gap-1 cursor-pointer px-3 py-1 rounded border text-sm
                          ${editingMealTicket.drink === d.key ? 'bg-blue-100 border-blue-400' : 'bg-white hover:bg-gray-50'}`}>
                          <input 
                            type="radio" 
                            name="drink"
                            checked={editingMealTicket.drink === d.key}
                            onChange={() => setEditingMealTicket({...editingMealTicket, drink: d.key})}
                            className="hidden"
                          />
                          <span>{d.label}</span>
                        </label>
                      ))}
                    </div>
                  </div>
                  <div>
                    <label className="text-sm font-bold text-gray-600 block mb-1">間食</label>
                    <div className="flex gap-2">
                      {MEAL_SNACK.map(s => (
                        <label key={s.key} className={`flex items-center gap-1 cursor-pointer px-3 py-1 rounded border text-sm
                          ${editingMealTicket.snack === s.key ? 'bg-blue-100 border-blue-400' : 'bg-white hover:bg-gray-50'}`}>
                          <input 
                            type="radio" 
                            name="snack"
                            checked={editingMealTicket.snack === s.key}
                            onChange={() => setEditingMealTicket({...editingMealTicket, snack: s.key})}
                            className="hidden"
                          />
                          <span>{s.label}</span>
                        </label>
                      ))}
                    </div>
                  </div>
                </div>

                {/* メモ */}
                <div className="mb-4">
                  <label className="text-sm font-bold text-gray-600 block mb-1">メモ</label>
                  <textarea
                    value={editingMealTicket.memo || ''}
                    onChange={(e) => setEditingMealTicket({...editingMealTicket, memo: e.target.value})}
                    className="w-full p-2 border rounded text-sm"
                    rows={2}
                    placeholder="備考があれば入力"
                  />
                </div>

                {/* ボタン */}
                <div className="flex gap-2">
                  <button
                    onClick={() => {
                      setShowMealTicketModal(false);
                      setEditingMealTicket(null);
                    }}
                    className="flex-1 bg-gray-200 hover:bg-gray-300 text-gray-700 py-2 rounded font-bold"
                  >
                    キャンセル
                  </button>
                  <button
                    onClick={async () => {
                      try {
                        // 保存
                        const ticketKey = `${editingMealTicket.userId}_${editingMealTicket.startDate}_${editingMealTicket.endDate}`;
                        if (isFirebaseEnabled && database) {
                          await database.ref(`data/${STORAGE_KEY_MEAL_TICKETS}/${ticketKey}`).set(editingMealTicket);
                        } else {
                          setMealTickets(prev => ({
                            ...prev,
                            [ticketKey]: editingMealTicket
                          }));
                        }
                        setShowMealTicketModal(false);
                        setEditingMealTicket(null);
                        alert('食事伝票を保存しました');
                      } catch (e) {
                        console.error('保存エラー:', e);
                        alert('保存に失敗しました: ' + e.message);
                      }
                    }}
                    className="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 rounded font-bold"
                  >
                    保存
                  </button>
                  <button
                    onClick={() => {
                      // PDF出力
                      const ticketKey = `${editingMealTicket.userId}_${editingMealTicket.startDate}_${editingMealTicket.endDate}`;
                      // 先に保存
                      setMealTickets(prev => ({
                        ...prev,
                        [ticketKey]: editingMealTicket
                      }));
                      // PDF生成
                      generateMealTicketPDF(editingMealTicket);
                    }}
                    className="flex-1 bg-green-500 hover:bg-green-600 text-white py-2 rounded font-bold"
                  >
                    📄 PDF出力
                  </button>
                </div>
              </div>
            </div>
          )}

          <div className={`grid grid-cols-1 ${sidebarCollapsed ? '' : 'lg:grid-cols-5'} gap-6 print-block`}>
            {/* 折りたたみ時のサイドバー展開ボタン */}
            {sidebarCollapsed && (
              <button
                onClick={() => setSidebarCollapsed(false)}
                className="fixed left-0 top-1/2 transform -translate-y-1/2 bg-blue-600 text-white px-2 py-4 rounded-r-lg shadow-lg hover:bg-blue-700 z-30 print-hidden"
                title="サイドバーを展開"
              >
                <span className="writing-mode-vertical">▶ 利用者</span>
              </button>
            )}
            
            {/* 左サイドバー */}
            {!sidebarCollapsed && (
            <div className="lg:col-span-1 space-y-4 print-hidden relative">
              <div className="bg-white p-4 rounded shadow-sm border border-gray-200 relative">
                <div className="flex justify-between items-center mb-2">
                  <h2 className="font-bold text-gray-700 flex items-center gap-2">
                    <User size={18} />
                    利用者リスト
                  </h2>
                  <div className="flex items-center gap-1">
                    <button
                      onClick={() => setUserSortOrder(prev => prev === 'asc' ? 'desc' : 'asc')}
                      className="text-xs bg-blue-500 hover:bg-blue-600 text-white px-2 py-1 rounded flex items-center gap-1 font-bold border border-blue-600"
                      title={userSortOrder === 'asc' ? '降順に変更' : '昇順に変更'}
                    >
                      {userSortOrder === 'asc' ? '▲ あ→ん' : '▼ ん→あ'}
                    </button>
                    <button
                      onClick={() => setSidebarCollapsed(true)}
                      className="text-xs bg-blue-500 hover:bg-blue-600 text-white px-2 py-1 rounded font-bold border border-blue-600"
                      title="サイドバーを折りたたむ"
                    >
                      ◀ 縮小
                    </button>
                  </div>
                </div>
                
                <div className="space-y-2 mb-4 max-h-[400px] overflow-y-auto">
                  {(() => {
                    // 6ヶ月前の日付を計算
                    const sixMonthsAgo = new Date();
                    sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
                    const sixMonthsAgoStr = toDateStr(sixMonthsAgo);
                    
                    // 表示対象のユーザーをフィルタリング
                    const visibleUsers = users.filter(user => {
                      // アーカイブ済みは非表示
                      if (user.isArchived) return false;
                      
                      // 利用日があれば、最新の利用日をチェック
                      if (user.stayDates && user.stayDates.length > 0) {
                        const latestStayDate = [...user.stayDates].sort().pop();
                        // 6ヶ月以内に利用があれば表示
                        if (latestStayDate >= sixMonthsAgoStr) return true;
                      }
                      
                      // 利用日がなくても、作成日が6ヶ月以内なら表示
                      if (user.createdAt) {
                        const createdDate = toDateStr(new Date(user.createdAt));
                        if (createdDate >= sixMonthsAgoStr) return true;
                      }
                      
                      // 後方互換性：createdAtがない場合は表示
                      if (!user.createdAt) return true;
                      
                      return false;
                    });
                    
                    // 検索フィルタリング
                    const searchedUsers = userSearchQuery
                      ? visibleUsers.filter(user => 
                          user.name.toLowerCase().includes(userSearchQuery.toLowerCase())
                        )
                      : visibleUsers;
                    
                    // 50音順にソート（フリガナがあればフリガナを使用、カタカナはひらがなに変換）
                    const sortedUsers = [...searchedUsers].sort((a, b) => {
                      const aSort = katakanaToHiragana(a.furigana || a.name);
                      const bSort = katakanaToHiragana(b.furigana || b.name);
                      const comparison = aSort.localeCompare(bSort, 'ja');
                      return userSortOrder === 'asc' ? comparison : -comparison;
                    });
                    
                    if (sortedUsers.length === 0 && userSearchQuery) {
                      return <div className="text-center text-gray-400 py-4 text-sm">「{userSearchQuery}」に一致する利用者はいません</div>;
                    }
                    
                    return sortedUsers.map(user => (
                      <div key={user.id} className="p-2 border rounded bg-gray-50 flex justify-between items-start group">
                        <div>
                          <div className="font-bold text-gray-800">{user.name}</div>
                          <div className="flex flex-wrap gap-1 mt-1">
                            {user.conditions.map(c => {
                              const label = CONDITIONS.find(def => def.key === c)?.label;
                              return label ? <span key={c} className="text-[10px] bg-blue-100 text-blue-800 px-1 rounded">{label}</span> : null;
                            })}
                            {/* 医療情報アイコン */}
                            {user.medical?.insulin && <span className="text-[10px] bg-red-100 text-red-800 px-1 rounded">💉ｲﾝｽﾘﾝ</span>}
                            {user.medical?.gastrostomy && <span className="text-[10px] bg-red-100 text-red-800 px-1 rounded">🔴胃ろう</span>}
                            {user.medical?.oxygenTherapy && <span className="text-[10px] bg-red-100 text-red-800 px-1 rounded">🫁酸素</span>}
                          </div>
                          <div className="text-sm text-gray-600 mt-1">
                            利用日数: {user.stayDates.filter(d => d.startsWith(toDateStr(currentMonth).slice(0, 7))).length}日
                            {user.bathType && <span className="ml-2 text-blue-600 font-bold">🛁{BATH_TYPES.find(b => b.key === user.bathType)?.label}</span>}
                            {user.fixedRooms && Object.keys(user.fixedRooms).length > 0 && (
                              <span className="ml-2 text-yellow-600 font-bold">🔒{Object.keys(user.fixedRooms).length}期間固定</span>
                            )}
                          </div>
                          {/* 送迎情報（簡易表示） */}
                          {(user.transport?.pickupMethod || user.transport?.pickupTime || user.transport?.dropoffTime) && (
                            <div className="text-[10px] text-green-700 mt-1">
                              🚗{user.transport.pickupMethod || ''}{user.transport.pickupTime && ` 迎${user.transport.pickupTime}`}{user.transport.dropoffTime && ` 送${user.transport.dropoffTime}`}{user.transport.wheelchairNeeded && ' 🦽車いす要'}
                            </div>
                          )}
                          {/* 居宅事業所（簡易表示） */}
                          {user.careManager?.officeName && (
                            <div className="text-[10px] text-purple-700 mt-1">
                              📋{user.careManager.officeName}{user.careManager.staffName && ` (${user.careManager.staffName})`}
                            </div>
                          )}
                        </div>
                        <div className="flex gap-1">
                          <button onClick={() => handleEditUser(user)} className="text-gray-400 hover:text-blue-500 p-1 opacity-0 group-hover:opacity-100 transition-opacity" title="編集">
                            <Edit size={16} />
                          </button>
                          <button 
                            onClick={() => {
                              // 食事伝票一覧を表示（利用期間ごと）
                              const periods = getStayPeriods(user.stayDates);
                              if (periods.length === 0) {
                                alert('利用日程がありません');
                                return;
                              }
                              // 最初の期間の伝票を開く（または新規作成）
                              const period = periods[0];
                              const periodStart = period[0];
                              const periodEnd = period[period.length - 1];
                              const ticketKey = `${user.id}_${periodStart}_${periodEnd}`;
                              const existingTicket = mealTickets[ticketKey];
                              
                              if (existingTicket) {
                                setEditingMealTicket(existingTicket);
                              } else {
                                setEditingMealTicket({
                                  userId: user.id,
                                  startDate: periodStart,
                                  endDate: periodEnd,
                                  unit: '樹',
                                  startMeal: '',
                                  endMeal: '',
                                  category: '',
                                  reason: '',
                                  foodType: '',
                                  diabetesKcal: '',
                                  mainDish: '',
                                  mainDishOther: '',
                                  sideDish: '',
                                  sideDishOther: '',
                                  drink: '',
                                  snack: '',
                                  memo: ''
                                });
                              }
                              setShowMealTicketModal(true);
                            }} 
                            className="text-gray-400 hover:text-green-500 p-1 opacity-0 group-hover:opacity-100 transition-opacity"
                            title="食事伝票"
                          >
                            🍽️
                          </button>
                          <button onClick={() => deleteUser(user.id)} className="text-gray-400 hover:text-red-500 p-1 opacity-0 group-hover:opacity-100 transition-opacity" title="削除">
                            <Trash2 size={16} />
                          </button>
                        </div>
                      </div>
                    ));
                  })()}
                </div>

                <button 
                  onClick={() => {
                    setNewUserOpen(!newUserOpen);
                    setSelectionStart(null);
                    setEditingUser(null);
                    setNewUserData({ 
                      name: '', 
                      furigana: '', 
                      gender: '',
                      birthDate: '',
                      birthDateMode: 'wareki',
                      birthEra: '',
                      birthYear: '',
                      birthMonth: '',
                      birthDay: '',
                      conditions: [], 
                      stayDates: [], 
                      fixedRooms: {}, 
                      bathType: '',
                      medical: { insulin: false, gastrostomy: false, oxygenTherapy: false },
                      transport: { pickupTime: '', dropoffTime: '', address: '', pickupMethod: '', wheelchairNeeded: false, note: '' },
                      careManager: { officeName: '', staffName: '', phone: '', fax: '', mobile: '' }
                    });
                    setCalendarMonth(currentMonth); // カレンダー月をリセット
                  }}
                  className="w-full flex justify-center items-center gap-2 border-2 border-dashed border-gray-300 p-2 rounded text-gray-500 hover:border-blue-400 hover:text-blue-500 transition-colors"
                >
                  <Plus size={16} />
                  {newUserOpen ? '閉じる' : '新規追加'}
                </button>

                {newUserOpen && (
                  <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                    <div className="bg-white rounded-lg shadow-xl p-5 w-[400px] max-w-[90vw] max-h-[85vh] overflow-y-auto">
                    <div className="flex justify-between items-center mb-3">
                      <h3 className="font-bold text-gray-700 text-lg">{editingUser ? '利用者情報の編集' : '新規登録'}</h3>
                      <button onClick={() => {
                        setNewUserOpen(false);
                        setEditingUser(null);
                        setNewUserData({ 
                          name: '', 
                          furigana: '', 
                          gender: '',
                          birthDate: '',
                          birthDateMode: 'wareki',
                          birthEra: '',
                          birthYear: '',
                          birthMonth: '',
                          birthDay: '',
                          conditions: [], 
                          stayDates: [], 
                          fixedRooms: {}, 
                          bathType: '',
                          medical: { insulin: false, gastrostomy: false, oxygenTherapy: false },
                          transport: { pickupTime: '', dropoffTime: '', address: '', pickupMethod: '', wheelchairNeeded: false, note: '' },
                          careManager: { officeName: '', staffName: '', phone: '', fax: '', mobile: '' }
                        });
                        setCalendarMonth(currentMonth);
                      }} className="text-gray-400 hover:text-gray-600 text-2xl leading-none">&times;</button>
                    </div>
                    <input 
                      type="text" 
                      placeholder="氏名" 
                      className="w-full p-2 border rounded mb-2 bg-white"
                      value={newUserData.name}
                      onChange={(e) => setNewUserData({...newUserData, name: e.target.value})}
                    />
                    <input 
                      type="text" 
                      placeholder="フリガナ（カタカナ・50音順用）" 
                      className="w-full p-2 border rounded mb-3 bg-white text-sm text-gray-600"
                      value={newUserData.furigana}
                      onChange={(e) => setNewUserData({...newUserData, furigana: e.target.value})}
                      onBlur={(e) => setNewUserData({...newUserData, furigana: hiraganaToKatakana(e.target.value)})}
                    />
                    
                    {/* 性別・生年月日・ユニット */}
                    <div className="mb-3">
                      <label className="text-xs text-gray-500 block mb-1">性別</label>
                      <select
                        value={newUserData.gender || ''}
                        onChange={(e) => setNewUserData({...newUserData, gender: e.target.value})}
                        className="w-full p-2 border rounded bg-white text-sm"
                      >
                        <option value="">選択</option>
                        <option value="male">男性</option>
                        <option value="female">女性</option>
                      </select>
                    </div>
                    <div className="mb-3">
                      <div className="flex items-center justify-between mb-1">
                        <label className="text-xs text-gray-500">生年月日</label>
                        <label className="flex items-center gap-1 text-xs text-gray-500 cursor-pointer">
                          <input
                            type="checkbox"
                            checked={newUserData.birthDateMode === 'western'}
                            onChange={(e) => setNewUserData({...newUserData, birthDateMode: e.target.checked ? 'western' : 'wareki'})}
                            className="rounded"
                          />
                          西暦入力
                        </label>
                      </div>
                      {newUserData.birthDateMode === 'western' ? (
                        <input 
                          type="date" 
                          className="w-full p-2 border rounded bg-white text-sm"
                          value={newUserData.birthDate || ''}
                          onChange={(e) => setNewUserData({...newUserData, birthDate: e.target.value})}
                        />
                      ) : (
                        <div className="flex gap-1">
                          <select
                            value={newUserData.birthEra || ''}
                            onChange={(e) => {
                              const era = e.target.value;
                              setNewUserData({...newUserData, birthEra: era});
                            }}
                            className="p-2 border rounded bg-white text-sm"
                          >
                            <option value="">元号</option>
                            <option value="reiwa">令和</option>
                            <option value="heisei">平成</option>
                            <option value="showa">昭和</option>
                            <option value="taisho">大正</option>
                          </select>
                          <input
                            type="number"
                            placeholder="年"
                            min="1"
                            max="99"
                            className="w-16 p-2 border rounded bg-white text-sm"
                            value={newUserData.birthYear || ''}
                            onChange={(e) => {
                              const year = e.target.value;
                              setNewUserData({...newUserData, birthYear: year});
                              // 和暦から西暦に変換してbirthDateも更新
                              if (newUserData.birthEra && year && newUserData.birthMonth && newUserData.birthDay) {
                                const eraStart = {reiwa: 2018, heisei: 1988, showa: 1925, taisho: 1911};
                                const westernYear = eraStart[newUserData.birthEra] + parseInt(year);
                                const dateStr = `${westernYear}-${String(newUserData.birthMonth).padStart(2,'0')}-${String(newUserData.birthDay).padStart(2,'0')}`;
                                setNewUserData(prev => ({...prev, birthYear: year, birthDate: dateStr}));
                              }
                            }}
                          />
                          <select
                            value={newUserData.birthMonth || ''}
                            onChange={(e) => {
                              const month = e.target.value;
                              setNewUserData({...newUserData, birthMonth: month});
                              if (newUserData.birthEra && newUserData.birthYear && month && newUserData.birthDay) {
                                const eraStart = {reiwa: 2018, heisei: 1988, showa: 1925, taisho: 1911};
                                const westernYear = eraStart[newUserData.birthEra] + parseInt(newUserData.birthYear);
                                const dateStr = `${westernYear}-${String(month).padStart(2,'0')}-${String(newUserData.birthDay).padStart(2,'0')}`;
                                setNewUserData(prev => ({...prev, birthMonth: month, birthDate: dateStr}));
                              }
                            }}
                            className="p-2 border rounded bg-white text-sm"
                          >
                            <option value="">月</option>
                            {[...Array(12)].map((_, i) => <option key={i+1} value={i+1}>{i+1}月</option>)}
                          </select>
                          <select
                            value={newUserData.birthDay || ''}
                            onChange={(e) => {
                              const day = e.target.value;
                              setNewUserData({...newUserData, birthDay: day});
                              if (newUserData.birthEra && newUserData.birthYear && newUserData.birthMonth && day) {
                                const eraStart = {reiwa: 2018, heisei: 1988, showa: 1925, taisho: 1911};
                                const westernYear = eraStart[newUserData.birthEra] + parseInt(newUserData.birthYear);
                                const dateStr = `${westernYear}-${String(newUserData.birthMonth).padStart(2,'0')}-${String(day).padStart(2,'0')}`;
                                setNewUserData(prev => ({...prev, birthDay: day, birthDate: dateStr}));
                              }
                            }}
                            className="p-2 border rounded bg-white text-sm"
                          >
                            <option value="">日</option>
                            {[...Array(31)].map((_, i) => <option key={i+1} value={i+1}>{i+1}日</option>)}
                          </select>
                        </div>
                      )}
                      {newUserData.birthDate && (
                        <p className="text-xs text-gray-500 mt-1">
                          → {(() => {
                            const d = parseLocalDate(newUserData.birthDate);
                            const year = d.getFullYear();
                            let era = '', eraYear = 0;
                            if (year >= 2019) { era = '令和'; eraYear = year - 2018; }
                            else if (year >= 1989) { era = '平成'; eraYear = year - 1988; }
                            else if (year >= 1926) { era = '昭和'; eraYear = year - 1925; }
                            else { era = '大正'; eraYear = year - 1911; }
                            return `${era}${eraYear}年${d.getMonth()+1}月${d.getDate()}日 (${year}年)`;
                          })()}
                        </p>
                      )}
                    </div>
                    
                    <div className="mb-3">
                      <p className="text-xs font-bold text-gray-600 mb-1">条件設定:</p>
                      <div className="flex flex-col gap-1">
                        {CONDITIONS.map(cond => (
                          <label key={cond.key} className="flex items-center gap-2 cursor-pointer hover:bg-blue-100 p-1 rounded border border-transparent hover:border-blue-200">
                            <input 
                              type="checkbox" 
                              checked={newUserData.conditions.includes(cond.key)}
                              onChange={() => toggleCondition(cond.key)}
                              className="rounded text-blue-600"
                            />
                            <span className="text-xs text-gray-700">{cond.label}</span>
                          </label>
                        ))}
                      </div>
                    </div>

                    <div className="mb-3">
                      <p className="text-xs font-bold text-gray-600 mb-1">入浴方法:</p>
                      <div className="flex flex-wrap gap-2">
                        {BATH_TYPES.map(bath => (
                          <label key={bath.key} className="flex items-center gap-1 cursor-pointer">
                            <input 
                              type="radio" 
                              name="bathType"
                              value={bath.key}
                              checked={newUserData.bathType === bath.key}
                              onChange={(e) => setNewUserData({...newUserData, bathType: e.target.value})}
                              className="text-blue-600"
                            />
                            <span className="text-xs text-gray-700">{bath.label}</span>
                          </label>
                        ))}
                        <label className="flex items-center gap-1 cursor-pointer">
                          <input 
                            type="radio" 
                            name="bathType"
                            value=""
                            checked={newUserData.bathType === ''}
                            onChange={(e) => setNewUserData({...newUserData, bathType: ''})}
                            className="text-blue-600"
                          />
                          <span className="text-xs text-gray-400">未設定</span>
                        </label>
                      </div>
                    </div>

                    <div className="mb-3">
                      <p className="text-xs font-bold text-gray-600 mb-1">🔒 部屋固定:</p>
                      <p className="text-xs text-gray-500 bg-yellow-50 p-2 rounded border border-yellow-200">
                        予定表で利用者を右クリックすると、その利用期間の部屋を固定できます。<br/>
                        固定された利用は黄色で表示されます。
                      </p>
                      {newUserData.fixedRooms && Object.keys(newUserData.fixedRooms).length > 0 && (
                        <div className="mt-2 text-xs">
                          <span className="text-yellow-600 font-bold">現在の固定: </span>
                          {Object.entries(newUserData.fixedRooms).map(([period, roomId]) => (
                            <span key={period} className="bg-yellow-100 px-1 rounded mr-1">{period.replace('_', '〜')} → {roomId}号室</span>
                          ))}
                        </div>
                      )}
                    </div>

                    {/* 医療情報 */}
                    <div className="mb-3 p-3 bg-red-50 rounded border border-red-200">
                      <p className="text-xs font-bold text-red-700 mb-2">🏥 医療情報:</p>
                      <div className="flex flex-wrap gap-3">
                        <label className="flex items-center gap-2 cursor-pointer">
                          <input 
                            type="checkbox" 
                            checked={newUserData.medical?.insulin || false}
                            onChange={(e) => setNewUserData({...newUserData, medical: {...newUserData.medical, insulin: e.target.checked}})}
                            className="rounded text-red-600"
                          />
                          <span className="text-xs text-gray-700">インスリン</span>
                        </label>
                        <label className="flex items-center gap-2 cursor-pointer">
                          <input 
                            type="checkbox" 
                            checked={newUserData.medical?.gastrostomy || false}
                            onChange={(e) => setNewUserData({...newUserData, medical: {...newUserData.medical, gastrostomy: e.target.checked}})}
                            className="rounded text-red-600"
                          />
                          <span className="text-xs text-gray-700">胃ろう</span>
                        </label>
                        <label className="flex items-center gap-2 cursor-pointer">
                          <input 
                            type="checkbox" 
                            checked={newUserData.medical?.oxygenTherapy || false}
                            onChange={(e) => setNewUserData({...newUserData, medical: {...newUserData.medical, oxygenTherapy: e.target.checked}})}
                            className="rounded text-red-600"
                          />
                          <span className="text-xs text-gray-700">在宅酸素</span>
                        </label>
                      </div>
                    </div>

                    {/* 送迎データ */}
                    <div className="mb-3 p-3 bg-green-50 rounded border border-green-200">
                      <p className="text-xs font-bold text-green-700 mb-2">🚗 送迎情報:</p>
                      <div className="space-y-2">
                        <div className="grid grid-cols-2 gap-2">
                          <div>
                            <label className="text-[10px] text-gray-500">迎え時間</label>
                            <input 
                              type="text" 
                              placeholder="例: 10:00" 
                              className="w-full p-2 border rounded bg-white text-sm"
                              value={newUserData.transport?.pickupTime || ''}
                              onChange={(e) => setNewUserData({...newUserData, transport: {...newUserData.transport, pickupTime: e.target.value}})}
                            />
                          </div>
                          <div>
                            <label className="text-[10px] text-gray-500">送り時間</label>
                            <input 
                              type="text" 
                              placeholder="例: 15:00" 
                              className="w-full p-2 border rounded bg-white text-sm"
                              value={newUserData.transport?.dropoffTime || ''}
                              onChange={(e) => setNewUserData({...newUserData, transport: {...newUserData.transport, dropoffTime: e.target.value}})}
                            />
                          </div>
                        </div>
                        <input 
                          type="text" 
                          placeholder="住所" 
                          className="w-full p-2 border rounded bg-white text-sm"
                          value={newUserData.transport?.address || ''}
                          onChange={(e) => setNewUserData({...newUserData, transport: {...newUserData.transport, address: e.target.value}})}
                        />
                        <div className="flex flex-wrap gap-2 items-center">
                          <span className="text-xs text-gray-600">迎え方法:</span>
                          {['施設送迎', '家族', '介護タクシー'].map(method => (
                            <label key={method} className="flex items-center gap-1 cursor-pointer">
                              <input 
                                type="radio" 
                                name="pickupMethod"
                                value={method}
                                checked={newUserData.transport?.pickupMethod === method}
                                onChange={(e) => setNewUserData({...newUserData, transport: {...newUserData.transport, pickupMethod: e.target.value}})}
                                className="text-green-600"
                              />
                              <span className="text-xs text-gray-700">{method}</span>
                            </label>
                          ))}
                          <label className="flex items-center gap-1 cursor-pointer">
                            <input 
                              type="radio" 
                              name="pickupMethod"
                              value=""
                              checked={!newUserData.transport?.pickupMethod}
                              onChange={(e) => setNewUserData({...newUserData, transport: {...newUserData.transport, pickupMethod: ''}})}
                              className="text-green-600"
                            />
                            <span className="text-xs text-gray-400">未設定</span>
                          </label>
                        </div>
                        <label className="flex items-center gap-2 cursor-pointer">
                          <input 
                            type="checkbox" 
                            checked={newUserData.transport?.wheelchairNeeded || false}
                            onChange={(e) => setNewUserData({...newUserData, transport: {...newUserData.transport, wheelchairNeeded: e.target.checked}})}
                            className="rounded text-green-600"
                          />
                          <span className="text-xs text-gray-700">車いすの用意が必要</span>
                        </label>
                        <input 
                          type="text" 
                          placeholder="送迎備考" 
                          className="w-full p-2 border rounded bg-white text-sm"
                          value={newUserData.transport?.note || ''}
                          onChange={(e) => setNewUserData({...newUserData, transport: {...newUserData.transport, note: e.target.value}})}
                        />
                      </div>
                    </div>

                    {/* 居宅介護支援事業所 */}
                    <div className="mb-3 p-3 bg-purple-50 rounded border border-purple-200">
                      <p className="text-xs font-bold text-purple-700 mb-2">📋 居宅介護支援事業所:</p>
                      <div className="space-y-2">
                        <input 
                          type="text" 
                          placeholder="事業所名" 
                          className="w-full p-2 border rounded bg-white text-sm"
                          value={newUserData.careManager?.officeName || ''}
                          onChange={(e) => setNewUserData({...newUserData, careManager: {...newUserData.careManager, officeName: e.target.value}})}
                        />
                        <input 
                          type="text" 
                          placeholder="担当ケアマネ名" 
                          className="w-full p-2 border rounded bg-white text-sm"
                          value={newUserData.careManager?.staffName || ''}
                          onChange={(e) => setNewUserData({...newUserData, careManager: {...newUserData.careManager, staffName: e.target.value}})}
                        />
                        <div className="grid grid-cols-2 gap-2">
                          <input 
                            type="text" 
                            placeholder="事業所電話番号" 
                            className="p-2 border rounded bg-white text-sm"
                            value={newUserData.careManager?.phone || ''}
                            onChange={(e) => setNewUserData({...newUserData, careManager: {...newUserData.careManager, phone: e.target.value}})}
                          />
                          <input 
                            type="text" 
                            placeholder="事業所FAX番号" 
                            className="p-2 border rounded bg-white text-sm"
                            value={newUserData.careManager?.fax || ''}
                            onChange={(e) => setNewUserData({...newUserData, careManager: {...newUserData.careManager, fax: e.target.value}})}
                          />
                        </div>
                        <input 
                          type="text" 
                          placeholder="ケアマネ携帯番号" 
                          className="w-full p-2 border rounded bg-white text-sm"
                          value={newUserData.careManager?.mobile || ''}
                          onChange={(e) => setNewUserData({...newUserData, careManager: {...newUserData.careManager, mobile: e.target.value}})}
                        />
                      </div>
                    </div>

                    {/* 食事伝票一覧（編集時のみ表示・当月分） */}
                    {editingUser && editingUser.stayDates && editingUser.stayDates.length > 0 && (
                      <div className="mb-3 p-3 bg-green-50 rounded border border-green-200">
                        <p className="text-xs font-bold text-green-700 mb-2">🍽️ 食事伝票（{currentMonth.getFullYear()}年{currentMonth.getMonth() + 1}月）:</p>
                        <div className="space-y-1">
                          {(() => {
                            const monthStr = `${currentMonth.getFullYear()}-${String(currentMonth.getMonth() + 1).padStart(2, '0')}`;
                            const periods = getStayPeriods(editingUser.stayDates);
                            const currentMonthPeriods = periods.filter(period => {
                              const periodStart = period[0];
                              return periodStart.startsWith(monthStr);
                            });
                            
                            if (currentMonthPeriods.length === 0) {
                              return <p className="text-xs text-gray-500">当月の利用期間はありません</p>;
                            }
                            
                            return currentMonthPeriods.map((period, index) => {
                              const periodStart = period[0];
                              const periodEnd = period[period.length - 1];
                              const ticketKey = `${editingUser.id}_${periodStart}_${periodEnd}`;
                              const hasTicket = mealTickets[ticketKey];
                              return (
                                <div key={index} className="flex items-center justify-between bg-white p-2 rounded border">
                                  <span className="text-xs">
                                    {periodStart} ～ {periodEnd}
                                    {hasTicket ? (
                                      <span className="ml-2 text-green-600 font-bold">✓作成済み</span>
                                    ) : (
                                      <span className="ml-2 text-gray-400">未作成</span>
                                    )}
                                  </span>
                                  <button
                                    type="button"
                                    onClick={() => {
                                      const existingTicket = mealTickets[ticketKey];
                                      if (existingTicket) {
                                        setEditingMealTicket(existingTicket);
                                      } else {
                                        setEditingMealTicket({
                                          userId: editingUser.id,
                                          startDate: periodStart,
                                          endDate: periodEnd,
                                          unit: '樹',
                                          startMeal: '',
                                          endMeal: '',
                                          category: '',
                                          reason: '',
                                          foodType: '',
                                          diabetesKcal: '',
                                          mainDish: '',
                                        mainDishOther: '',
                                          sideDish: '',
                                        sideDishOther: '',
                                          drink: '',
                                          snack: '',
                                          memo: ''
                                        });
                                      }
                                      setShowMealTicketModal(true);
                                    }}
                                    className={`text-xs px-2 py-1 rounded ${hasTicket ? 'bg-green-500 hover:bg-green-600 text-white' : 'bg-blue-500 hover:bg-blue-600 text-white'}`}
                                  >
                                    {hasTicket ? '編集' : '作成'}
                                  </button>
                                </div>
                              );
                            });
                          })()}
                        </div>
                      </div>
                    )}

                    <div className="mb-4">
                      <div className="flex justify-between items-end mb-2">
                        <p className="text-xs font-bold text-gray-600">利用日選択:</p>
                        <div className="flex gap-1">
                          <button 
                            type="button"
                            onClick={clearSelectedDates}
                            className="text-[10px] text-red-500 bg-red-50 px-2 py-0.5 rounded hover:bg-red-100 border border-red-200"
                          >
                            全てクリア
                          </button>
                          <span className="text-[10px] text-blue-600 font-bold bg-blue-50 px-2 py-0.5 rounded border border-blue-200">
                            {selectionStart ? "終了日を選択" : "期間を追加"}
                          </span>
                        </div>
                      </div>
                      {renderCalendarGrid()}
                      {newUserData.stayDates.length > 0 && (
                        <div className="mt-2 p-2 bg-gray-50 rounded text-[10px] text-gray-600">
                          <span className="font-bold">選択中: </span>
                          {(() => {
                            const sortedDates = [...newUserData.stayDates].sort();
                            if (sortedDates.length === 0) return '';
                            const periods = getStayPeriods(sortedDates);
                            return periods.map((period, i) => {
                              const start = period[0];
                              const end = period[period.length - 1];
                              const startObj = parseLocalDate(start);
                              const endObj = parseLocalDate(end);
                              const startStr = `${startObj.getMonth()+1}/${startObj.getDate()}`;
                              const endStr = `${endObj.getMonth()+1}/${endObj.getDate()}`;
                              return (
                                <span key={i} className="inline-flex items-center bg-blue-100 text-blue-800 px-1 rounded mr-1 mb-1">
                                  {start === end ? startStr : `${startStr}〜${endStr}`}
                                  <button
                                    type="button"
                                    onClick={() => {
                                      setNewUserData(prev => ({
                                        ...prev,
                                        stayDates: prev.stayDates.filter(d => !period.includes(d))
                                      }));
                                    }}
                                    className="ml-1 text-red-500 hover:text-red-700 font-bold"
                                    title="この期間を削除"
                                  >×</button>
                                </span>
                              );
                            });
                          })()}
                        </div>
                      )}
                      <p className="text-[10px] text-gray-400 mt-1 text-center">開始日→終了日でクリック追加 / 選択済みの日付をクリックで削除</p>
                    </div>

                    <button 
                      onClick={handleSaveUser}
                      disabled={!newUserData.name}
                      className="w-full bg-blue-600 text-white p-2 rounded hover:bg-blue-700 disabled:opacity-50 font-bold"
                    >
                      {editingUser ? '更新' : 'リストに追加'}
                    </button>
                    </div>
                  </div>
                )}
              </div>

              <div className="bg-white p-4 rounded shadow-sm border border-gray-200">
                <div className="flex justify-between items-center mb-2">
                  <h3 className="font-bold text-sm text-gray-700 flex items-center gap-2"><MapPin size={16}/> 部屋条件</h3>
                  <button
                    onClick={() => {
                      setEditingRooms(JSON.parse(JSON.stringify(rooms)));
                      setShowRoomEditor(true);
                    }}
                    className="text-xs bg-blue-500 hover:bg-blue-600 text-white px-2 py-1 rounded font-bold"
                  >
                    ✏️ 編集
                  </button>
                </div>
                <ul className="text-sm text-gray-600 space-y-1">
                  {rooms.map(room => (
                    <li key={room.id} className="flex">
                      <span className="font-bold w-12 text-gray-800">{room.name}</span>
                      <span className="text-gray-600">: {room.label || '通常'}</span>
                    </li>
                  ))}
                </ul>
              </div>
              
              <div className="text-right">
                <button onClick={clearAllData} className="text-xs text-gray-400 hover:text-red-500 underline">
                  全データを削除してリセット
                </button>
              </div>
            </div>
            )}

            {/* メインエリア */}
            <div className={`${sidebarCollapsed ? 'col-span-1' : 'lg:col-span-4'} bg-white rounded shadow-sm border border-gray-200 p-2 print-col-span-5 print-shadow-none print-border-none print-p-0 flex flex-col`} style={{height: headerCollapsed ? 'calc(100vh - 60px)' : 'calc(100vh - 120px)'}}>
              {/* 一時保管に利用者がいる場合の警告 */}
              {(() => {
                const tempUserCount = displayDates.reduce((count, dateStr) => {
                  const tempKey1 = `${dateStr}-${TEMP_ROOM_1_ID}`;
                  const tempKey2 = `${dateStr}-${TEMP_ROOM_2_ID}`;
                  return count + (allocations[tempKey1] || []).length + (allocations[tempKey2] || []).length;
                }, 0);
                if (tempUserCount > 0) {
                  return (
                    <div className="bg-red-600 text-white px-6 py-4 rounded-lg mb-2 print-hidden border-4 border-yellow-400 shadow-lg" 
                         style={{animation: 'blink 0.5s ease-in-out infinite'}}>
                      <style>{`
                        @keyframes blink {
                          0%, 100% { opacity: 1; background-color: #dc2626; }
                          50% { opacity: 0.8; background-color: #b91c1c; }
                        }
                      `}</style>
                      <div className="flex items-center justify-center gap-4">
                        <span className="text-5xl">🚨</span>
                        <div className="text-center">
                          <div className="text-3xl font-black mb-1">⚠️ 警告 ⚠️</div>
                          <div className="text-2xl font-bold">一時保管に {tempUserCount} 件の利用者が残っています！</div>
                          <div className="text-lg mt-1">部屋の割り当てを完了してください</div>
                        </div>
                        <span className="text-5xl">🚨</span>
                      </div>
                      <div className="flex justify-center mt-3">
                        <button 
                          onClick={() => {
                            if (tableContainerRef.current) {
                              tableContainerRef.current.scrollTo({ top: tableContainerRef.current.scrollHeight, behavior: 'smooth' });
                            }
                          }}
                          className="bg-yellow-400 text-red-800 px-6 py-2 rounded-lg font-black text-lg hover:bg-yellow-300 shadow-md"
                        >
                          👇 一時保管を確認する 👇
                        </button>
                      </div>
                    </div>
                  );
                }
                return null;
              })()}
              <div className="print-hidden mb-2 flex justify-between items-center flex-shrink-0">
                <div className="flex gap-2">
                  <button
                    onClick={() => scrollTable('left')}
                    className="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded shadow flex items-center gap-1 font-bold"
                  >
                    ◀ 左へ
                  </button>
                  <button
                    onClick={() => scrollTable('right')}
                    className="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded shadow flex items-center gap-1 font-bold"
                  >
                    右へ ▶
                  </button>
                  <button
                    onClick={() => {
                      if (tableContainerRef.current) {
                        const today = new Date();
                        const dayOfMonth = today.getDate();
                        const cellWidth = 48; // 約48pxセル幅
                        const scrollPosition = (dayOfMonth - 1) * cellWidth;
                        tableContainerRef.current.scrollTo({
                          left: scrollPosition,
                          behavior: 'smooth'
                        });
                      }
                    }}
                    className="bg-yellow-500 hover:bg-yellow-600 text-white px-4 py-2 rounded shadow flex items-center gap-1 font-bold"
                  >
                    📅 今日
                  </button>
                  
                  {/* 稼働率表示 */}
                  {(() => {
                    // 右下の実績数と同じ計算式を使用
                    const totalCount = displayDates.reduce((total, dateStr) => {
                      return total + rooms.reduce((count, room) => {
                        const key = `${dateStr}-${room.id}`;
                        const occupants = allocations[key] || [];
                        return count + occupants.length;
                      }, 0);
                    }, 0);
                    const maxCapacity = rooms.length * displayDates.length;
                    const occupancyRate = maxCapacity > 0 ? ((totalCount / maxCapacity) * 100).toFixed(1) : 0;
                    return (
                      <div className="bg-white border-2 border-yellow-500 rounded px-3 py-1 text-center">
                        <div className="text-lg font-black text-gray-800">{totalCount}</div>
                        <div className="text-xs text-gray-500">({occupancyRate}%)</div>
                      </div>
                    );
                  })()}
                </div>
                <div className="text-lg text-gray-500">
                  ※利用者名をドラッグで部屋移動 / 右クリックで一時保管へ移動。アイコン（🛁・🛏️）は同利用者の他の日に移動可。
                </div>
              </div>
              <div ref={tableContainerRef} className="flex-1 min-h-0 overflow-auto">
              
              <h2 className="hidden print-block text-2xl font-bold text-center mb-4">
                {currentMonth.getFullYear()}年 {currentMonth.getMonth() + 1}月 ショートステイ部屋割表
              </h2>

              <table className={`w-full border-collapse text-xs print-min-w-full print-text-10px ${displayDates.length > 14 ? 'min-w-[2000px]' : ''}`}>
                <thead className="sticky top-0 z-20">
                  <tr>
                    <th className="p-2 border-2 border-gray-400 bg-gray-100 text-center text-xl font-bold sticky left-0 z-30 shadow-sm print-static print-shadow-none" style={{width: '150px', minWidth: '150px'}}>部屋</th>
                    {displayDates.map((dateStr, i) => {
                      const dateObj = parseLocalDate(dateStr);
                      const dayOfWeek = dateObj.getDay();
                      const isSun = dayOfWeek === 0;
                      const isSat = dayOfWeek === 6;
                      const holiday = HOLIDAYS_JP[dateStr];
                      const isRed = isSun || holiday; // 日曜または祝日は赤
                      const today = toDateStr(new Date());
                      const isPastHeader = dateStr < today;
                      const isToday = dateStr === today;
                      
                      // インラインスタイルで確実に色を適用
                      let bgColor = '#f9fafb'; // gray-50
                      let textColor = '#374151'; // gray-700
                      
                      if (isRed) {
                        bgColor = isPastHeader ? '#fca5a5' : '#fef2f2'; // red-300/red-50
                        textColor = isPastHeader ? '#b91c1c' : '#dc2626'; // red-700/red-600
                      } else if (isSat) {
                        bgColor = isPastHeader ? '#93c5fd' : '#eff6ff'; // blue-300/blue-50
                        textColor = isPastHeader ? '#1d4ed8' : '#2563eb'; // blue-700/blue-600
                      } else if (isPastHeader) {
                        bgColor = '#9ca3af'; // gray-400
                        textColor = '#374151'; // gray-700
                      }
                      
                      return (
                        <th key={dateStr} className={`p-1 border-2 border-gray-400 text-center ${cellWidth}`}
                          style={{ 
                            backgroundColor: bgColor,
                            borderLeftWidth: isToday ? '6px' : undefined,
                            borderLeftColor: isToday ? '#1e3a8a' : undefined,
                            borderLeftStyle: isToday ? 'solid' : undefined
                          }}
                          title={holiday || ''}
                        >
                          <div className="text-sm font-bold"
                            style={{ color: textColor }}>
                            <div>{dateObj.getMonth() + 1}/{dateObj.getDate()}</div>
                            <div>{WEEK_DAYS_JP[dayOfWeek]}</div>
                          </div>
                          {holiday && <div className="text-[8px] truncate" style={{ color: '#ef4444' }}>{holiday}</div>}
                        </th>
                      );
                    })}
                    <th className="p-1 border-2 border-gray-400 text-center bg-yellow-100 min-w-[150px]">
                      <div className="text-base font-bold text-gray-700">実績</div>
                    </th>
                  </tr>
                </thead>
                <tbody>
                  {rooms.map(room => (
                    <tr key={room.id} className="hover:bg-gray-50 print-break-inside-avoid">
                      <td className="p-1 border-2 border-gray-400 align-middle bg-white sticky left-0 z-10 shadow-sm print-static print-shadow-none text-center" style={{width: '150px', minWidth: '150px'}}>
                        <div className="flex flex-col items-center">
                          <span className="font-bold text-3xl text-gray-800">{room.name}</span>
                          <div className="flex flex-wrap gap-1 mt-1 justify-center">
                            {room.features.includes('reserved_i') && <span className="text-lg bg-purple-100 text-purple-700 px-2 py-0.5 rounded whitespace-nowrap">I様</span>}
                            {room.features.includes('near_toilet') && <span className="text-lg bg-green-100 text-green-700 px-2 py-0.5 rounded whitespace-nowrap">トイレ</span>}
                            {room.features.includes('low_fall_risk') && <span className="text-lg bg-orange-100 text-orange-700 px-2 py-0.5 rounded whitespace-nowrap">転倒低</span>}
                            {room.features.includes('for_new') && <span className="text-lg bg-teal-100 text-teal-700 px-2 py-0.5 rounded whitespace-nowrap">新規</span>}
                            {room.features.includes('for_oxygen') && <span className="text-lg bg-red-100 text-red-700 px-2 py-0.5 rounded whitespace-nowrap">酸素</span>}
                          </div>
                        </div>
                      </td>
                      {displayDates.map((dateStr) => {
                        const allocatedIds = allocations[`${dateStr}-${room.id}`] || [];
                        const dateObj = parseLocalDate(dateStr);
                        const isWeekend = dateObj.getDay() === 0 || dateObj.getDay() === 6;
                        
                        const sortedIds = [...allocatedIds].sort((a, b) => {
                          const userA = users.find(u => u.id === a);
                          const userB = users.find(u => u.id === b);
                          if (!userA || !userB) return 0;
                          const aIsLeaving = !userA.stayDates.includes(getNextDay(dateStr));
                          const bIsLeaving = !userB.stayDates.includes(getNextDay(dateStr));
                          return (aIsLeaving === bIsLeaving) ? 0 : aIsLeaving ? -1 : 1;
                        });

                        const isRoomDragOver = dragOverRoom === `${dateStr}-${room.id}`;
                        
                        // 今日の日付を取得して過去かどうか判定
                        const today = toDateStr(new Date());
                        const isPast = dateStr < today;
                        const isToday = dateStr === today;
                        const isEmpty = sortedIds.length === 0;
                        const hasDoubleBooking = sortedIds.length >= 2; // 同日に2人いる場合

                        return (
                          <td 
                            key={dateStr} 
                            className={`p-0 h-24 align-top relative 
                              ${hasDoubleBooking ? 'border-4 border-red-500' : 'border-2 border-gray-400'}
                              ${isRoomDragOver ? 'bg-yellow-100 border-2 border-dashed border-yellow-500' : ''}`}
                            style={{
                              backgroundColor: isRoomDragOver ? undefined : 
                                isEmpty ? '#00FE73' : 
                                isPast ? '#9ca3af' : 
                                isWeekend ? 'rgba(249, 250, 251, 0.5)' : 'white',
                              borderLeftWidth: isToday ? '6px' : undefined,
                              borderLeftColor: isToday ? '#1e3a8a' : undefined
                            }}
                            onDragOver={(e) => handleRoomDragOver(e, dateStr, room.id)}
                            onDragLeave={handleRoomDragLeave}
                            onDrop={(e) => handleRoomDrop(e, dateStr, room.id)}
                          >
                            <div className="flex flex-col h-full">
                              <div className="flex-1 flex flex-col min-h-0">
                                {sortedIds.length > 0 ? (
                                  sortedIds.map((userId, idx) => {
                                    const user = users.find(u => u.id === userId);
                                    if (!user) {
                                      // ユーザーが見つからない場合でも最低限の表示
                                      return (
                                        <div key={userId} className="flex-1 p-0.5 text-[10px] font-bold bg-gray-200 text-gray-500 text-center">
                                          (削除済み)
                                        </div>
                                      );
                                    }
                                    
                                    const isCheckIn = !user.stayDates.includes(getPrevDay(dateStr));
                                    const isCheckOut = !user.stayDates.includes(getNextDay(dateStr));
                                    
                                    const userSchedule = user.schedule || {};
                                    const daySchedule = userSchedule[dateStr] || { bath: false, mustBath: false, linen: false };
                                    
                                    const isDragOver = dragOverTarget === `${userId}-${dateStr}`;
                                    
                                    // パフォーマンス改善：事前に計算した色情報を参照
                                    const colorIndex = roomUserColors[`${room.id}-${userId}`] ?? 0;
                                    // この日付が属する期間に固定があるかチェック
                                    const periods = getStayPeriods(user.stayDates || []);
                                    const currentPeriod = periods.find(p => p.includes(dateStr));
                                    const periodKey = currentPeriod ? `${currentPeriod[0]}_${currentPeriod[currentPeriod.length - 1]}` : '';
                                    const isFixedInPeriod = periodKey && user.fixedRooms && user.fixedRooms[periodKey];
                                    // 部屋固定の利用者は黄色、それ以外はピンク/スカイブルー
                                    const userBgColor = isFixedInPeriod ? 'bg-yellow-200' : (colorIndex === 0 ? 'bg-pink-200' : 'bg-sky-200');
                                    const userTextColor = isFixedInPeriod ? 'text-yellow-800' : (colorIndex === 0 ? 'text-pink-800' : 'text-sky-800');
                                    
                                    // 同日IN/OUT時の点線表示判定
                                    // 前の利用者が退室者で、現在の利用者が非退室者なら点線を入れる
                                    let showInOutDivider = false;
                                    if (idx > 0 && !isCheckOut) {
                                      const prevUserId = sortedIds[idx - 1];
                                      const prevUser = users.find(u => u.id === prevUserId);
                                      if (prevUser) {
                                        const prevIsCheckOut = !prevUser.stayDates.includes(getNextDay(dateStr));
                                        showInOutDivider = prevIsCheckOut;
                                      }
                                    }
                                    
                                    return (
                                      <React.Fragment key={userId}>
                                        {showInOutDivider && (
                                          <div className="border-t-2 border-dashed border-gray-400 mx-0" style={{borderColor: '#666'}} />
                                        )}
                                        <div 
                                          draggable
                                          onDragStart={(e) => handleUserDragStart(e, userId, dateStr, room.id)}
                                          onDragEnd={handleUserDragEnd}
                                          onDragOver={(e) => handleDragOver(e, userId, dateStr)}
                                          onDragLeave={handleDragLeave}
                                          onDrop={(e) => handleDrop(e, userId, dateStr)}
                                          onContextMenu={(e) => handleContextMenu(e, userId, dateStr, room.id)}
                                          className={`
                                            flex-1 p-0.5 text-[10px] font-bold border-b border-gray-100 last:border-b-0 flex flex-col justify-center text-center overflow-hidden relative transition-colors cursor-grab active:cursor-grabbing group/cell
                                            ${userBgColor} ${userTextColor}
                                            ${isDragOver ? 'drag-over' : ''}
                                            ${isPast ? 'opacity-40' : ''}
                                          `}
                                          title="ドラッグで部屋移動 / 右クリックで一時保管へ"
                                        >
                                        <div className="leading-tight w-full z-10">
                                          <div className="flex justify-center items-center gap-0.5 mb-0.5">
                                            {isCheckOut && sortedIds.length > 1 && <span className="text-[7px] text-red-600 leading-none">▲退</span>}
                                            {isCheckIn && sortedIds.length > 1 && <span className="text-[7px] text-green-700 leading-none">▼入</span>}
                                          </div>
                                          <span className="truncate block" style={{
                                            fontSize: user.name.length <= 4 ? '14px' : user.name.length === 5 ? '12px' : '10px',
                                            fontWeight: 'bold'
                                          }}>{user.name}</span>
                                        </div>

                                        <div className="flex justify-center gap-1 mt-0.5 z-20 flex-wrap">
                                          {(daySchedule.mustBath || daySchedule.bath) ? (
                                            <span 
                                              draggable 
                                              onDragStart={(e) => { e.stopPropagation(); handleDragStart(e, userId, dateStr, daySchedule.mustBath ? 'mustBath' : 'bath'); }}
                                              onDragEnd={handleDragEnd}
                                              onClick={(e) => {
                                                e.stopPropagation();
                                                if (!daySchedule.mustBath) {
                                                  // mustBath以外は削除可能
                                                  setUsers(users.map(u => {
                                                    if (u.id === userId) {
                                                  const updatedUser = { ...u, schedule: { ...u.schedule } };
                                                  updatedUser.schedule[dateStr] = { ...updatedUser.schedule[dateStr], bath: false };
                                                  return updatedUser;
                                                    }
                                                    return u;
                                              })); // ローカルの即時反映用
                                              if (isFirebaseEnabled && database) {
                                                // Firebaseに直接書き込み
                                                const userIndex = users.findIndex(u => u.id === userId);
                                                if (userIndex !== -1) {
                                                  const path = `data/${STORAGE_KEY_USERS}/${userIndex}/schedule/${dateStr}/bath`;
                                                  database.ref(path).set(false);
                                                }
                                              }
                                                }
                                              }}
                                              className={`text-2xl cursor-pointer hover:opacity-80 drop-shadow-md rounded ${daySchedule.mustBath ? 'cursor-grab' : 'hover:bg-red-100'}`}
                                              title={daySchedule.mustBath ? "退所前日入浴（ドラッグで移動）" : "入浴予定（クリックで削除/ドラッグで移動）"}>🛁</span>
                                          ) : (
                                            <button
                                              onClick={(e) => {
                                                e.stopPropagation();
                                                const newUsers = users.map(u => {
                                                  if (u.id === userId) {
                                                    const updatedUser = { ...u, schedule: { ...u.schedule } };
                                                    updatedUser.schedule[dateStr] = { ...updatedUser.schedule[dateStr], bath: true };
                                                    return updatedUser;
                                                  }
                                                  return u;
                                                });
                                                if (isFirebaseEnabled && database) {
                                                  // users全体を更新
                                                  database.ref('data/' + STORAGE_KEY_USERS).set(newUsers);
                                                } else {
                                                  setUsers(newUsers);
                                                }
                                              }}
                                              className="text-[10px] text-blue-400 hover:text-blue-600 hover:bg-blue-100 rounded px-1 opacity-0 group-hover/cell:opacity-100 transition-opacity"
                                              title="入浴を追加"
                                            >+🛁</button>
                                          )}
                                          {daySchedule.linen ? (
                                            <span 
                                              draggable 
                                              onDragStart={(e) => { e.stopPropagation(); handleDragStart(e, userId, dateStr, 'linen'); }}
                                              onDragEnd={handleDragEnd}
                                              onClick={(e) => {
                                                e.stopPropagation();
                                                const newUsers = users.map(u => {
                                                  if (u.id === userId) {
                                                    const updatedUser = { ...u, schedule: { ...u.schedule } };
                                                    updatedUser.schedule[dateStr] = { ...updatedUser.schedule[dateStr], linen: false };
                                                    return updatedUser;
                                                  }
                                                  return u;
                                                });
                                                if (isFirebaseEnabled && database) {
                                                  // users全体を更新
                                                  database.ref('data/' + STORAGE_KEY_USERS).set(newUsers);
                                                } else {
                                                  setUsers(newUsers);
                                                }
                                              }}
                                              className="text-2xl cursor-pointer hover:opacity-80 drop-shadow-md hover:bg-red-100 rounded" 
                                              title="リネン交換（クリックで削除/ドラッグで移動）">🛏️</span>
                                          ) : (
                                            <button
                                              onClick={(e) => {
                                                e.stopPropagation();
                                                const newUsers = users.map(u => {
                                                  if (u.id === userId) {
                                                    const updatedUser = { ...u, schedule: { ...u.schedule } };
                                                    updatedUser.schedule[dateStr] = { ...updatedUser.schedule[dateStr], linen: true };
                                                    return updatedUser;
                                                  }
                                                  return u;
                                                });
                                                if (isFirebaseEnabled && database) {
                                                  database.ref('data/' + STORAGE_KEY_USERS).set(newUsers);
                                                } else {
                                                  setUsers(newUsers);
                                                }
                                              }}
                                              className="text-[10px] text-green-400 hover:text-green-600 hover:bg-green-100 rounded px-1 opacity-0 group-hover/cell:opacity-100 transition-opacity"
                                              title="リネン交換を追加"
                                            >+🛏️</button>
                                          )}
                                        </div>
                                      </div>
                                      </React.Fragment>
                                    );
                                  })
                                ) : (
                                  <div className="flex-1"></div>
                                )}
                              </div>

                              <MemoInput
                                value={memos[`${dateStr}-${room.id}`] || ''}
                                onSave={(val) => handleMemoChange(dateStr, room.id, val)}
                                className={`w-full h-6 text-[9px] border-t border-gray-200 p-1 outline-none text-red-600 font-bold placeholder-gray-300 focus:bg-yellow-50 print-placeholder-transparent ${isPast ? 'bg-gray-300' : 'bg-white'}`}
                                placeholder="メモ"
                              />
                            </div>
                          </td>
                        );
                      })}
                      {/* 部屋ごとの月間実績 */}
                      <td className="p-2 border-2 border-gray-400 bg-yellow-50 text-center align-middle min-w-[150px]">
                        <span className="font-bold text-2xl text-gray-800">
                          {displayDates.reduce((count, dateStr) => {
                            const key = `${dateStr}-${room.id}`;
                            const occupants = allocations[key] || [];
                            return count + occupants.length;
                          }, 0)}
                        </span>
                      </td>
                    </tr>
                  ))}
                </tbody>
                <tfoot>
                  {/* 空行 - 印刷時は非表示 */}
                  <tr className="print-hidden">
                    <td className="p-1 border-2 border-gray-400 bg-gray-50"></td>
                    {displayDates.map(dateStr => (
                      <td key={dateStr} className="p-1 border-2 border-gray-400 bg-gray-50"></td>
                    ))}
                    <td className="p-1 border-2 border-gray-400 bg-gray-50 min-w-[150px]"></td>
                  </tr>
                  {/* 実績数行 */}
                  <tr className="bg-yellow-100" style={{height: '54px'}}>
                    <td className="p-2 border-2 border-gray-400 bg-yellow-200 font-bold text-xl text-gray-800 sticky left-0 z-10 text-center whitespace-nowrap" style={{width: '150px', minWidth: '150px'}}>
                      実績数
                    </td>
                    {displayDates.map(dateStr => {
                      // その日の全部屋の利用者数を合計
                      const dailyCount = rooms.reduce((count, room) => {
                        const key = `${dateStr}-${room.id}`;
                        const occupants = allocations[key] || [];
                        return count + occupants.length;
                      }, 0);
                      const today = toDateStr(new Date());
                      const isToday = dateStr === today;
                      return (
                        <td key={dateStr} className="p-1 border-2 border-gray-400 bg-yellow-100 text-center align-middle"
                          style={{
                            borderLeftWidth: isToday ? '6px' : undefined,
                            borderLeftColor: isToday ? '#1e3a8a' : undefined
                          }}
                        >
                          <span className="font-bold text-xl text-gray-800">{dailyCount}</span>
                        </td>
                      );
                    })}
                    {/* 当月合計 */}
                    <td className="p-2 border-2 border-gray-400 bg-yellow-200 text-center min-w-[150px]">
                      {(() => {
                        const totalCount = displayDates.reduce((total, dateStr) => {
                          return total + rooms.reduce((count, room) => {
                            const key = `${dateStr}-${room.id}`;
                            const occupants = allocations[key] || [];
                            return count + occupants.length;
                          }, 0);
                        }, 0);
                        const maxCapacity = rooms.length * displayDates.length;
                        const occupancyRate = maxCapacity > 0 ? ((totalCount / maxCapacity) * 100).toFixed(1) : 0;
                        return (
                          <div>
                            <div className="font-bold text-2xl text-gray-800">{totalCount}</div>
                            <div className="text-sm text-gray-600 font-bold">({occupancyRate}%)</div>
                          </div>
                        );
                      })()}
                    </td>
                  </tr>
                  {/* 一時保管部屋1 */}
                  <tr className="bg-orange-50 print-hidden" style={{height: '60px'}}>
                    <td className="p-1 border-2 border-orange-400 bg-orange-200 font-bold text-sm text-orange-800 sticky left-0 z-10 text-center" style={{width: '150px', minWidth: '150px'}}>
                      <div>一時保管①</div>
                    </td>
                      {displayDates.map(dateStr => {
                      const tempKey = `${dateStr}-${TEMP_ROOM_1_ID}`;
                      const tempOccupants = allocations[tempKey] || [];
                      const isRoomDragOver = dragOverRoom === `${dateStr}-${TEMP_ROOM_1_ID}`;
                      const today = toDateStr(new Date());
                      const isToday = dateStr === today;
                      
                      return (
                        <td 
                          key={dateStr} 
                          className={`p-0 border-2 border-orange-400 align-top relative
                            ${tempOccupants.length > 0 ? 'bg-orange-100' : 'bg-orange-50'}
                            ${isRoomDragOver ? 'bg-yellow-100 border-dashed border-yellow-500' : ''}`}
                          style={{
                            borderLeftWidth: isToday ? '6px' : undefined,
                            borderLeftColor: isToday ? '#1e3a8a' : undefined
                          }}
                          onDragOver={(e) => handleRoomDragOver(e, dateStr, TEMP_ROOM_1_ID)}
                          onDragLeave={handleRoomDragLeave}
                          onDrop={(e) => handleRoomDrop(e, dateStr, TEMP_ROOM_1_ID)}
                        >
                          <div className="flex flex-col h-full">
                            {tempOccupants.map((userId) => {
                              const user = users.find(u => u.id === userId);
                              if (!user) return null;
                              return (
                                <div 
                                  key={userId}
                                  draggable
                                  onDragStart={(e) => handleUserDragStart(e, userId, dateStr, TEMP_ROOM_1_ID)}
                                  onDragEnd={handleUserDragEnd}
                                  onContextMenu={(e) => handleContextMenu(e, userId, dateStr, TEMP_ROOM_1_ID)}
                                  className="flex-1 p-1 text-xs font-bold bg-orange-300 text-orange-900 text-center cursor-grab active:cursor-grabbing border-b border-orange-400 last:border-b-0"
                                  title="ドラッグで部屋移動 / 右クリックで移動先選択"
                                >
                                  {user.name}
                                </div>
                              );
                            })}
                          </div>
                        </td>
                      );
                    })}
                    <td className="p-1 border-2 border-orange-400 bg-orange-200 min-w-[150px] text-center text-orange-800 font-bold">
                      {displayDates.reduce((count, dateStr) => {
                        const tempKey = `${dateStr}-${TEMP_ROOM_1_ID}`;
                        return count + (allocations[tempKey] || []).length;
                      }, 0)}
                    </td>
                  </tr>
                  {/* 一時保管部屋2 */}
                  <tr className="bg-orange-50 print-hidden" style={{height: '60px'}}>
                    <td className="p-1 border-2 border-orange-400 bg-orange-200 font-bold text-sm text-orange-800 sticky left-0 z-10 text-center" style={{width: '150px', minWidth: '150px'}}>
                      <div>一時保管②</div>
                    </td>
                    {displayDates.map(dateStr => {
                      const tempKey = `${dateStr}-${TEMP_ROOM_2_ID}`;
                      const tempOccupants = allocations[tempKey] || [];
                      const isRoomDragOver = dragOverRoom === `${dateStr}-${TEMP_ROOM_2_ID}`;
                      const today = toDateStr(new Date());
                      const isToday = dateStr === today;
                      
                      return (
                        <td 
                          key={dateStr} 
                          className={`p-0 border-2 border-orange-400 align-top relative
                            ${tempOccupants.length > 0 ? 'bg-orange-100' : 'bg-orange-50'}
                            ${isRoomDragOver ? 'bg-yellow-100 border-dashed border-yellow-500' : ''}`}
                          style={{
                            borderLeftWidth: isToday ? '6px' : undefined,
                            borderLeftColor: isToday ? '#1e3a8a' : undefined
                          }}
                          onDragOver={(e) => handleRoomDragOver(e, dateStr, TEMP_ROOM_2_ID)}
                          onDragLeave={handleRoomDragLeave}
                          onDrop={(e) => handleRoomDrop(e, dateStr, TEMP_ROOM_2_ID)}
                        >
                          <div className="flex flex-col h-full">
                            {tempOccupants.map((userId) => {
                              const user = users.find(u => u.id === userId);
                              if (!user) return null;
                              return (
                                <div 
                                  key={userId}
                                  draggable
                                  onDragStart={(e) => handleUserDragStart(e, userId, dateStr, TEMP_ROOM_2_ID)}
                                  onDragEnd={handleUserDragEnd}
                                  onContextMenu={(e) => handleContextMenu(e, userId, dateStr, TEMP_ROOM_2_ID)}
                                  className="flex-1 p-1 text-xs font-bold bg-orange-300 text-orange-900 text-center cursor-grab active:cursor-grabbing border-b border-orange-400 last:border-b-0"
                                  title="ドラッグで部屋移動 / 右クリックで移動先選択"
                                >
                                  {user.name}
                                </div>
                              );
                            })}
                          </div>
                        </td>
                      );
                    })}
                    <td className="p-1 border-2 border-orange-400 bg-orange-200 min-w-[150px] text-center text-orange-800 font-bold">
                      {displayDates.reduce((count, dateStr) => {
                        const tempKey = `${dateStr}-${TEMP_ROOM_2_ID}`;
                        return count + (allocations[tempKey] || []).length;
                      }, 0)}
                    </td>
                  </tr>
                  
                  {/* カスタム行（キャンセル待ち等） */}
                  {customRows.map((customRow) => (
                    <tr key={customRow.id} className="bg-sky-50" style={{height: '40px'}}>
                      <td className="p-1 border border-gray-400 bg-sky-200 font-bold text-sm text-sky-800 sticky left-0 z-10 text-center" style={{width: '150px', minWidth: '150px'}}>
                        <div className="flex flex-col items-center gap-0">
                          <span className="text-xs">{customRow.name}</span>
                          <button
                            onClick={() => {
                              if (window.confirm(`「${customRow.name}」を削除しますか？`)) {
                                const newRows = customRows.filter(r => r.id !== customRow.id);
                                if (isFirebaseEnabled && database) {
                                  database.ref('data/' + STORAGE_KEY_CUSTOM_ROWS).set(newRows);
                                } else {
                                  setCustomRows(newRows);
                                }
                              }
                            }}
                            className="text-xs text-red-500 hover:text-red-700 print-hidden"
                          >
                            ✕削除
                          </button>
                        </div>
                      </td>
                      {displayDates.map(dateStr => {
                        const memoKey1 = `${dateStr}-${customRow.id}-1`;
                        const memoKey2 = `${dateStr}-${customRow.id}-2`;
                        const today = toDateStr(new Date());
                        const isToday = dateStr === today;
                        return (
                          <td 
                            key={dateStr} 
                            className="p-0 border border-gray-400 bg-white align-top"
                            style={{
                              borderLeftWidth: isToday ? '6px' : undefined,
                              borderLeftColor: isToday ? '#1e3a8a' : undefined
                            }}
                          >
                            <div className="flex flex-col h-full">
                              <MemoInput
                                value={customRowMemos[memoKey1] || ''}
                                onSave={(val) => {
                                  if (isFirebaseEnabled && database) {
                                    database.ref(`data/${STORAGE_KEY_CUSTOM_ROW_MEMOS}/${memoKey1}`).set(val);
                                  } else {
                                    setCustomRowMemos(prev => ({...prev, [memoKey1]: val}));
                                  }
                                }}
                                className="w-full flex-1 p-0.5 text-xs bg-white outline-none text-gray-800 placeholder-gray-300 focus:bg-yellow-50 border-b border-gray-200"
                                placeholder=""
                              />
                              <MemoInput
                                value={customRowMemos[memoKey2] || ''}
                                onSave={(val) => {
                                  if (isFirebaseEnabled && database) {
                                    database.ref(`data/${STORAGE_KEY_CUSTOM_ROW_MEMOS}/${memoKey2}`).set(val);
                                  } else {
                                    setCustomRowMemos(prev => ({...prev, [memoKey2]: val}));
                                  }
                                }}
                                className="w-full flex-1 p-0.5 text-xs bg-white outline-none text-gray-800 placeholder-gray-300 focus:bg-yellow-50"
                                placeholder=""
                              />
                            </div>
                          </td>
                        );
                      })}
                      <td className="p-1 border border-gray-400 bg-sky-200 min-w-[150px] text-center">
                        {/* 実績列は空白 */}
                      </td>
                    </tr>
                  ))}
                  
                  {/* カスタム行追加ボタン */}
                  <tr className="print-hidden">
                    <td className="p-1 border-2 border-dashed border-teal-300 bg-teal-50 sticky left-0 z-10" style={{width: '150px', minWidth: '150px'}}>
                      <button
                        onClick={() => {
                          const name = window.prompt('追加する行の名前を入力してください', '');
                          if (name && name.trim()) {
                            const newId = `custom_${Date.now()}`;
                            const newRows = [...customRows, { id: newId, name: name.trim() }];
                            if (isFirebaseEnabled && database) {
                              database.ref('data/' + STORAGE_KEY_CUSTOM_ROWS).set(newRows);
                            } else {
                              setCustomRows(newRows);
                            }
                          }
                        }}
                        className="w-full text-center text-teal-600 hover:text-teal-800 text-sm font-bold py-1"
                      >
                        ＋ 行を追加
                      </button>
                    </td>
                    {displayDates.map(dateStr => (
                      <td key={dateStr} className="border border-transparent"></td>
                    ))}
                    <td className="border border-transparent"></td>
                  </tr>
                  
                  {/* 空床利用部屋用の日付ヘッダー */}
                  {currentMonthTempRooms.length > 0 && (
                    <tr>
                      <td className="p-1 border-2 border-purple-400 bg-purple-100 text-center font-bold text-lg text-purple-700 sticky left-0 z-10" style={{width: '150px', minWidth: '150px'}}>
                        空床
                      </td>
                      {displayDates.map((dateStr) => {
                        const dateObj = parseLocalDate(dateStr);
                        const dayOfWeek = dateObj.getDay();
                        const isSun = dayOfWeek === 0;
                        const isSat = dayOfWeek === 6;
                        const holiday = HOLIDAYS_JP[dateStr];
                        const isRed = isSun || holiday;
                        const today = toDateStr(new Date());
                        const isToday = dateStr === today;
                        
                        let bgColor = '#f3e8ff'; // purple-100
                        let textColor = '#374151'; // gray-700
                        
                        if (isRed) {
                          bgColor = '#fecaca'; // red-200
                          textColor = '#dc2626'; // red-600
                        } else if (isSat) {
                          bgColor = '#bfdbfe'; // blue-200
                          textColor = '#2563eb'; // blue-600
                        }
                        
                        return (
                          <td key={dateStr} className={`p-1 border-2 border-purple-400 text-center ${cellWidth}`}
                            style={{ 
                              backgroundColor: bgColor,
                              borderLeftWidth: isToday ? '6px' : undefined,
                              borderLeftColor: isToday ? '#1e3a8a' : undefined
                            }}
                            title={holiday || ''}
                          >
                            <div className="text-xs font-bold" style={{ color: textColor }}>
                              <div>{dateObj.getMonth() + 1}/{dateObj.getDate()}</div>
                              <div>{WEEK_DAYS_JP[dayOfWeek]}</div>
                            </div>
                          </td>
                        );
                      })}
                      <td className="p-1 border-2 border-purple-400 bg-purple-100 min-w-[150px]"></td>
                    </tr>
                  )}
                  
                  {/* 空床利用部屋 */}
                  {currentMonthTempRooms.map((tempRoom) => (
                    <tr key={tempRoom.id} className="bg-purple-50" style={{height: '40px'}}>
                      <td className="p-2 border-2 border-purple-400 bg-purple-200 font-bold text-base text-purple-800 sticky left-0 z-10 text-center" style={{width: '150px', minWidth: '150px'}}>
                        {editingTempRoom === tempRoom.id ? (
                          <div className="flex flex-col gap-1">
                            <input
                              type="text"
                              defaultValue={tempRoom.name}
                              className="w-full text-xs p-1 border rounded text-center"
                              autoFocus
                              onBlur={(e) => {
                                const newName = e.target.value.trim();
                                if (newName) {
                                  const newTempRooms = tempRooms.map(r => 
                                    r.id === tempRoom.id ? { ...r, name: newName } : r
                                  );
                                  if (isFirebaseEnabled && database) {
                                    database.ref('data/' + STORAGE_KEY_TEMP_ROOMS).set(newTempRooms);
                                  } else {
                                    setTempRooms(newTempRooms);
                                  }
                                }
                                setEditingTempRoom(null);
                              }}
                              onKeyDown={(e) => {
                                if (e.key === 'Enter') {
                                  e.target.blur();
                                } else if (e.key === 'Escape') {
                                  setEditingTempRoom(null);
                                }
                              }}
                            />
                          </div>
                        ) : (
                          <div>
                            <div className="flex items-center justify-center gap-1">
                              <span>{tempRoom.name}</span>
                              <button
                                onClick={() => setEditingTempRoom(tempRoom.id)}
                                className="text-purple-600 hover:text-purple-800"
                                title="名前を編集"
                              >
                                ✏️
                              </button>
                            </div>
                            <button
                              onClick={() => {
                                if (window.confirm(`「${tempRoom.name}」を削除しますか？\n※割り当て済みの利用者は一時保管に移動します`)) {
                                  // この部屋の割り当てを一時保管に移動
                                  const newAllocations = { ...allocations };
                                  Object.keys(allocations).forEach(key => {
                                    if (key.endsWith(`-${tempRoom.id}`)) {
                                      const dateStr = key.split('-').slice(0,3).join('-'); // YYYY-MM-DD を取り出す
                                      const tempKey = `${dateStr}-${TEMP_ROOM_1_ID}`; // とりあえずTEMP1に移動
                                      newAllocations[tempKey] = [...(newAllocations[tempKey] || []), ...newAllocations[key]];
                                      delete newAllocations[key];
                                    }
                                  });
                                  const newTempRooms = tempRooms.filter(r => r.id !== tempRoom.id);
                                  if (isFirebaseEnabled && database) {
                                    database.ref().update({
                                      [`data/${STORAGE_KEY_ALLOCATIONS}`]: newAllocations,
                                      [`data/${STORAGE_KEY_TEMP_ROOMS}`]: newTempRooms,
                                    });
                                  } else {
                                    setAllocations(newAllocations);
                                    setTempRooms(newTempRooms);
                                  }
                                }
                              }}
                              className="text-xs text-red-500 hover:text-red-700 mt-1"
                              title="この空床部屋を削除"
                            >
                              🗑️削除
                            </button>
                            <button
                              onClick={() => {
                                const nextMonth = new Date(currentMonth.getFullYear(), currentMonth.getMonth() + 1, 1);
                                const nextMonthStr = `${nextMonth.getFullYear()}-${String(nextMonth.getMonth() + 1).padStart(2, '0')}`;
                                // 翌月に同名の空床が既にあるかチェック
                                const existsInNextMonth = tempRooms.some(r => r.month === nextMonthStr && r.name === tempRoom.name);
                                if (existsInNextMonth) {
                                  alert(`「${tempRoom.name}」は既に${nextMonth.getMonth() + 1}月にあります`);
                                  return;
                                }
                                const newId = `${TEMP_ROOM_PREFIX}${Date.now()}`;
                                const newTempRooms = [...tempRooms, { id: newId, name: tempRoom.name, month: nextMonthStr }];
                                if (isFirebaseEnabled && database) {
                                  database.ref('data/' + STORAGE_KEY_TEMP_ROOMS).set(newTempRooms);
                                } else {
                                  setTempRooms(newTempRooms);
                                }
                                alert(`「${tempRoom.name}」を${nextMonth.getMonth() + 1}月にコピーしました`);
                              }}
                              className="text-xs text-blue-500 hover:text-blue-700 mt-1"
                              title="翌月にコピー"
                            >
                              📋翌月へ
                            </button>
                          </div>
                        )}
                      </td>
                      {displayDates.map(dateStr => {
                        const roomKey = `${dateStr}-${tempRoom.id}`;
                        const occupants = allocations[roomKey] || [];
                        const isRoomDragOver = dragUser && dragUser.date === dateStr && dragOverRoom === tempRoom.id;
                        const today = toDateStr(new Date());
                        const isPast = dateStr < today;
                        const isToday = dateStr === today;
                        
                        return (
                          <td 
                            key={dateStr} 
                            className={`p-0 border border-gray-400 h-10 align-top relative
                              ${isRoomDragOver ? 'bg-yellow-100 border-2 border-dashed border-yellow-500' : ''}`}
                            style={{ 
                              backgroundColor: isRoomDragOver ? undefined : isPast ? '#9ca3af' : (occupants.length > 0 ? '#fef9c3' : '#ffffff'),
                              borderLeftWidth: isToday ? '6px' : undefined,
                              borderLeftColor: isToday ? '#1e3a8a' : undefined
                            }}
                            onDragOver={(e) => handleRoomDragOver(e, dateStr, tempRoom.id)}
                            onDragLeave={handleRoomDragLeave}
                            onDrop={(e) => handleRoomDrop(e, dateStr, tempRoom.id)}
                          >
                            <div className="flex flex-col h-full">
                              <div className={`flex-1 flex items-center justify-center ${isPast ? 'opacity-40' : ''}`}>
                                {occupants.length > 0 ? (
                                  <div 
                                    draggable
                                    onDragStart={(e) => handleUserDragStart(e, occupants[0], dateStr, tempRoom.id)}
                                    onDragEnd={handleUserDragEnd}
                                    onContextMenu={(e) => handleContextMenu(e, occupants[0], dateStr, tempRoom.id)}
                                    className="w-full text-xs font-bold text-gray-800 text-center cursor-grab active:cursor-grabbing"
                                    title="ドラッグで部屋移動 / 右クリックで移動先選択"
                                  >
                                    {users.find(u => u.id === occupants[0])?.name || ''}
                                  </div>
                                ) : null}
                              </div>
                              <MemoInput
                                value={memos[roomKey] || ''}
                                onSave={(val) => handleMemoChange(dateStr, tempRoom.id, val)}
                                className={`w-full h-4 text-[8px] border-t border-gray-300 p-0 outline-none text-red-600 font-bold placeholder-gray-300 focus:bg-yellow-50 print-placeholder-transparent ${isPast ? 'bg-gray-300' : 'bg-white'}`}
                                placeholder="メモ"
                              />
                            </div>
                          </td>
                        );
                      })}
                      <td className="p-1 border-2 border-purple-400 bg-purple-200 min-w-[150px] text-center text-purple-800 font-bold">
                        {displayDates.reduce((count, dateStr) => {
                          const roomKey = `${dateStr}-${tempRoom.id}`;
                          return count + (allocations[roomKey] || []).length;
                        }, 0)}
                      </td>
                    </tr>
                  ))}
                  
                  {/* 空床利用 実績数行 */}
                  {currentMonthTempRooms.length > 0 && (
                    <tr className="bg-purple-100" style={{height: '54px'}}>
                      <td className="p-2 border-2 border-purple-400 bg-purple-300 font-bold text-lg text-purple-900 sticky left-0 z-10 text-center whitespace-nowrap" style={{width: '150px', minWidth: '150px'}}>
                        空床実績
                      </td>
                      {displayDates.map(dateStr => {
                        // その日の空床利用部屋の利用者数を合計
                        const dailyCount = currentMonthTempRooms.reduce((count, tempRoom) => {
                          const key = `${dateStr}-${tempRoom.id}`;
                          const occupants = allocations[key] || [];
                          return count + occupants.length;
                        }, 0);
                        const today = toDateStr(new Date());
                        const isToday = dateStr === today;
                        return (
                          <td key={dateStr} className="p-1 border-2 border-purple-400 bg-purple-100 text-center align-middle"
                            style={{
                              borderLeftWidth: isToday ? '6px' : undefined,
                              borderLeftColor: isToday ? '#1e3a8a' : undefined
                            }}
                          >
                            <span className="font-bold text-xl text-purple-800">{dailyCount}</span>
                          </td>
                        );
                      })}
                      {/* 当月合計 */}
                      <td className="p-2 border-2 border-purple-400 bg-purple-300 text-center min-w-[150px]">
                        {(() => {
                          const totalCount = displayDates.reduce((total, dateStr) => {
                            return total + currentMonthTempRooms.reduce((count, tempRoom) => {
                              const key = `${dateStr}-${tempRoom.id}`;
                              const occupants = allocations[key] || [];
                              return count + occupants.length;
                            }, 0);
                          }, 0);
                          const maxCapacity = currentMonthTempRooms.length * displayDates.length;
                          const occupancyRate = maxCapacity > 0 ? ((totalCount / maxCapacity) * 100).toFixed(1) : 0;
                          return (
                            <div>
                              <div className="font-bold text-2xl text-purple-900">{totalCount}</div>
                              <div className="text-sm text-purple-700 font-bold">({occupancyRate}%)</div>
                            </div>
                          );
                        })()}
                      </td>
                    </tr>
                  )}
                  
                  {/* 合計実績行（通常＋空床） */}
                  {currentMonthTempRooms.length > 0 && (
                    <tr className="bg-green-100" style={{height: '54px'}}>
                      <td className="p-2 border-2 border-green-500 bg-green-300 font-bold text-lg text-green-900 sticky left-0 z-10 text-center whitespace-nowrap" style={{width: '150px', minWidth: '150px'}}>
                        合計実績
                      </td>
                      {displayDates.map(dateStr => {
                        // 通常部屋の利用者数
                        const normalCount = rooms.reduce((count, room) => {
                          const key = `${dateStr}-${room.id}`;
                          const occupants = allocations[key] || [];
                          return count + occupants.length;
                        }, 0);
                        // 空床利用部屋の利用者数
                        const tempCount = currentMonthTempRooms.reduce((count, tempRoom) => {
                          const key = `${dateStr}-${tempRoom.id}`;
                          const occupants = allocations[key] || [];
                          return count + occupants.length;
                        }, 0);
                        const totalDaily = normalCount + tempCount;
                        const today = toDateStr(new Date());
                        const isToday = dateStr === today;
                        return (
                          <td key={dateStr} className="p-1 border-2 border-green-500 bg-green-100 text-center align-middle"
                            style={{
                              borderLeftWidth: isToday ? '6px' : undefined,
                              borderLeftColor: isToday ? '#1e3a8a' : undefined
                            }}
                          >
                            <span className="font-bold text-xl text-green-800">{totalDaily}</span>
                          </td>
                        );
                      })}
                      {/* 当月合計 */}
                      <td className="p-2 border-2 border-green-500 bg-green-300 text-center min-w-[150px]">
                        {(() => {
                          // 通常部屋の合計
                          const normalTotal = displayDates.reduce((total, dateStr) => {
                            return total + rooms.reduce((count, room) => {
                              const key = `${dateStr}-${room.id}`;
                              const occupants = allocations[key] || [];
                              return count + occupants.length;
                            }, 0);
                          }, 0);
                          // 空床利用の合計
                          const tempTotal = displayDates.reduce((total, dateStr) => {
                            return total + currentMonthTempRooms.reduce((count, tempRoom) => {
                              const key = `${dateStr}-${tempRoom.id}`;
                              const occupants = allocations[key] || [];
                              return count + occupants.length;
                            }, 0);
                          }, 0);
                          const grandTotal = normalTotal + tempTotal;
                          // 稼働率は通常部屋のみで計算（空床は分子のみ加算）
                          const maxCapacity = rooms.length * displayDates.length;
                          const occupancyRate = maxCapacity > 0 ? ((grandTotal / maxCapacity) * 100).toFixed(1) : 0;
                          return (
                            <div>
                              <div className="font-bold text-2xl text-green-900">{grandTotal}</div>
                              <div className="text-sm text-green-700 font-bold">({occupancyRate}%)</div>
                            </div>
                          );
                        })()}
                      </td>
                    </tr>
                  )}
                  
                  {/* 空床追加ボタン行 */}
                  <tr className="bg-gray-50 print-hidden">
                    <td className="p-2 border border-gray-300 text-center">
                      <button
                        onClick={() => {
                          const newId = `${TEMP_ROOM_PREFIX}${Date.now()}`;
                          const monthStr = `${currentMonth.getFullYear()}-${String(currentMonth.getMonth() + 1).padStart(2, '0')}`;
                          const roomNumber = currentMonthTempRooms.length + 1;
                          const newTempRooms = [...tempRooms, { id: newId, name: `空床${roomNumber}`, month: monthStr }];
                          if (isFirebaseEnabled && database) {
                            database.ref('data/' + STORAGE_KEY_TEMP_ROOMS).set(newTempRooms);
                          } else {
                            setTempRooms(newTempRooms);
                          }
                        }}
                        className="bg-purple-500 hover:bg-purple-600 text-white px-2 py-1 rounded font-bold text-xs"
                      >
                        ＋ 空床追加
                      </button>
                    </td>
                    <td colSpan={displayDates.length + 1} className="border border-gray-300"></td>
                  </tr>
                </tfoot>
              </table>
              </div>
            </div>
          </div>
        </div>
        
        {/* 右クリックコンテキストメニュー（モーダル） */}
        {/* 同時編集: 接続ユーザーパネル */}
        {isFirebaseEnabled && connectedUsers.length > 0 && (
          <div className="connected-users-panel print-hidden">
            <div className="text-xs font-bold text-gray-500 mb-2">接続中 ({connectedUsers.length}人)</div>
            <div className="flex flex-wrap gap-2">
              {connectedUsers.map(user => (
                <div key={user.id} className="flex items-center gap-2" title={user.name}>
                  <div 
                    className="user-avatar" 
                    style={{ backgroundColor: user.color }}
                  >
                    {user.name.charAt(0)}
                  </div>
                  <span className="text-xs text-gray-600">
                    {user.name}
                    {user.id === CURRENT_USER_ID && ' (自分)'}
                  </span>
                </div>
              ))}
            </div>
          </div>
        )}

        {contextMenu && (
          <>
            <div 
              className="fixed inset-0 z-40 bg-black bg-opacity-30" 
              onClick={closeContextMenu}
            />
            <div 
              className="fixed z-50 bg-white rounded-xl shadow-2xl border-4 border-blue-400 py-4 w-80 left-1/2 top-1/2 transform -translate-x-1/2 -translate-y-1/2"
            >
              <div className="px-4 py-2 text-lg font-bold text-gray-700 border-b-2 mb-2 text-center bg-blue-50">
                🚚 {users.find(u => u.id === contextMenu.userId)?.name} を移動
              </div>
              
              {/* 部屋固定ボタン */}
              {!contextMenu.fromRoomId?.startsWith('TEMP') && (
                <div className="px-2 border-b-2 mb-2 pb-2">
                  {(() => {
                    const user = users.find(u => u.id === contextMenu.userId);
                    if (!user) return null;
                    
                    // contextMenu.dateが属する期間を特定
                    const periods = getStayPeriods(user.stayDates || []);
                    const currentPeriod = periods.find(p => p.includes(contextMenu.date));
                    if (!currentPeriod) return null;
                    
                    const periodKey = `${currentPeriod[0]}_${currentPeriod[currentPeriod.length - 1]}`;
                    const fixedRooms = user.fixedRooms || {};
                    const isFixed = fixedRooms[periodKey] === contextMenu.fromRoomId;
                    const periodLabel = currentPeriod.length > 1 
                      ? `${currentPeriod[0]} 〜 ${currentPeriod[currentPeriod.length - 1]}`
                      : currentPeriod[0];
                    
                    return isFixed ? (
                      <button
                        onClick={() => {
                          const newUsers = users.map(u => {
                            if (u.id === contextMenu.userId) {
                              const newFixedRooms = { ...u.fixedRooms };
                              delete newFixedRooms[periodKey];
                              return { ...u, fixedRooms: newFixedRooms };
                            }
                            return u;
                          });
                          if (isFirebaseEnabled && database) {
                            database.ref('data/' + STORAGE_KEY_USERS).set(newUsers);
                          } else {
                            setUsers(newUsers);
                          }
                          closeContextMenu();
                          alert(`${user.name}の部屋固定を解除しました\n（${periodLabel}）`);
                        }}
                        className="w-full text-left px-4 py-3 text-base rounded-lg bg-yellow-200 text-yellow-800 font-bold hover:bg-yellow-300 flex flex-col gap-1"
                      >
                        <div className="flex items-center gap-2">
                          🔓 この期間の部屋固定を解除
                        </div>
                        <div className="text-xs text-yellow-600">期間: {periodLabel} / {contextMenu.fromRoomId}号室</div>
                      </button>
                    ) : (
                      <button
                        onClick={() => {
                          const newUsers = users.map(u => {
                            if (u.id === contextMenu.userId) {
                              const newFixedRooms = { ...(u.fixedRooms || {}), [periodKey]: contextMenu.fromRoomId };
                              return { ...u, fixedRooms: newFixedRooms };
                            }
                            return u;
                          });
                          if (isFirebaseEnabled && database) {
                            database.ref('data/' + STORAGE_KEY_USERS).set(newUsers);
                          } else {
                            setUsers(newUsers);
                          }
                          closeContextMenu();
                          alert(`${user.name}を${contextMenu.fromRoomId}号室に固定しました\n（${periodLabel}）`);
                        }}
                        className="w-full text-left px-4 py-3 text-base rounded-lg bg-yellow-100 text-yellow-700 font-bold hover:bg-yellow-200 flex flex-col gap-1"
                      >
                        <div className="flex items-center gap-2">
                          🔒 この期間を{contextMenu.fromRoomId}号室に固定
                        </div>
                        <div className="text-xs text-yellow-600">期間: {periodLabel}</div>
                      </button>
                    );
                  })()}
                </div>
              )}
              
              {/* 一時保管を上部に配置 */}
              <div className="px-2 border-b-2 mb-2 pb-2 flex gap-2">
                <button
                  onClick={() => handleMoveToRoom(TEMP_ROOM_1_ID)}
                  disabled={contextMenu.fromRoomId === TEMP_ROOM_1_ID}
                  className={`flex-1 text-center px-2 py-2 text-sm rounded-lg hover:bg-orange-200
                    ${contextMenu.fromRoomId === TEMP_ROOM_1_ID ? 'bg-gray-100 text-gray-400 cursor-not-allowed' : 'bg-orange-100 text-orange-700 font-bold'}`}
                >
                  📦 一時保管①
                  {contextMenu.fromRoomId === TEMP_ROOM_1_ID && <span className="text-xs text-blue-500 block">（現在）</span>}
                </button>
                <button
                  onClick={() => handleMoveToRoom(TEMP_ROOM_2_ID)}
                  disabled={contextMenu.fromRoomId === TEMP_ROOM_2_ID}
                  className={`flex-1 text-center px-2 py-2 text-sm rounded-lg hover:bg-orange-200
                    ${contextMenu.fromRoomId === TEMP_ROOM_2_ID ? 'bg-gray-100 text-gray-400 cursor-not-allowed' : 'bg-orange-100 text-orange-700 font-bold'}`}
                >
                  📦 一時保管②
                  {contextMenu.fromRoomId === TEMP_ROOM_2_ID && <span className="text-xs text-blue-500 block">（現在）</span>}
                </button>
              </div>
              <div className="max-h-72 overflow-y-auto px-2">
                {rooms.map(room => {
                  const isCurrentRoom = contextMenu.fromRoomId === room.id;
                  const user = users.find(u => u.id === contextMenu.userId);
                  // この期間で固定されている部屋かチェック
                  const periods = getStayPeriods(user?.stayDates || []);
                  const currentPeriod = periods.find(p => p.includes(contextMenu.date));
                  const periodKey = currentPeriod ? `${currentPeriod[0]}_${currentPeriod[currentPeriod.length - 1]}` : '';
                  const isFixedRoom = periodKey && user?.fixedRooms && user.fixedRooms[periodKey] === room.id;
                  return (
                    <button
                      key={room.id}
                      onClick={() => handleMoveToRoom(room.id)}
                      disabled={isCurrentRoom}
                      className={`w-full text-left px-4 py-3 text-base rounded-lg mb-1 hover:bg-blue-100 flex items-center gap-2
                        ${isCurrentRoom ? 'bg-blue-200 text-blue-600 cursor-not-allowed' : isFixedRoom ? 'bg-yellow-100 text-yellow-700' : 'text-gray-700 bg-gray-50'}`}
                    >
                      <span className="font-bold text-lg">{room.id}</span>
                      <span className="text-sm text-gray-500">号室</span>
                      {isFixedRoom && <span className="text-sm text-yellow-600 ml-1">🔒</span>}
                      {isCurrentRoom && <span className="text-sm text-blue-600 ml-auto font-bold">（現在）</span>}
                    </button>
                  );
                })}
                
                {/* 空床利用部屋 */}
                {currentMonthTempRooms.length > 0 && (
                  <div className="border-t border-gray-200 mt-2 pt-2">
                    <div className="text-xs text-purple-600 font-bold px-2 mb-1">空床利用</div>
                    {currentMonthTempRooms.map(tempRoom => {
                      const isCurrentRoom = contextMenu.fromRoomId === tempRoom.id;
                      return (
                        <button
                          key={tempRoom.id}
                          onClick={() => handleMoveToRoom(tempRoom.id)}
                          disabled={isCurrentRoom}
                          className={`w-full text-left px-4 py-3 text-base rounded-lg mb-1 hover:bg-purple-100 flex items-center gap-2
                            ${isCurrentRoom ? 'bg-purple-200 text-purple-600 cursor-not-allowed' : 'text-gray-700 bg-purple-50'}`}
                        >
                          <span className="font-bold text-lg">{tempRoom.name}</span>
                          <span className="text-sm text-purple-500">（空床）</span>
                          {isCurrentRoom && <span className="text-sm text-purple-600 ml-auto font-bold">（現在）</span>}
                        </button>
                      );
                    })}
                  </div>
                )}
              </div>
              <div className="border-t-2 mt-2 pt-2 px-2">
                <button
                  onClick={closeContextMenu}
                  className="w-full text-center px-4 py-3 text-base text-gray-500 hover:bg-gray-100 rounded-lg font-bold"
                >
                  ✕ キャンセル
                </button>
              </div>
            </div>
          </>
        )}
        </>
      );
    }
    // ============================================
    // アプリのルート
    // ============================================
    function App() {
      const [isAuthenticated, setIsAuthenticated] = useState(false);
      const [isChecking, setIsChecking] = useState(true);
      
      // Firebase接続状態管理
      const [isFirebaseReady, setIsFirebaseReady] = useState(false);
      const [firebaseError, setFirebaseError] = useState(null);

      // Firebase初期化と認証監視
      useEffect(() => {
        let unsubscribe = null;

        const initFirebase = async () => {
          try {
            // Firebaseアプリの初期化（二重初期化防止）
            if (!firebase.apps.length) {
              firebase.initializeApp(FIREBASE_CONFIG);
            }

            // 認証状態の監視
            unsubscribe = firebase.auth().onAuthStateChanged(async (user) => {
              if (user) {
                setIsAuthenticated(true);
                // ログイン済みの場合、Firestoreに接続
                try {
                  const fs = firebase.firestore();
                  const docRef = fs.collection("ss-room-auto").doc("shared");
                  
                  // ドキュメントの存在確認を兼ねて初期化（権限があれば成功する）
                  // ※ルールで auth != null が必要なので、ここで行うのが正解
                  await docRef.set({ __init: true }, { merge: true });

                  // アダプタの初期化（グローバル変数にセット）
                  database = makeFirestoreRtdbAdapter(docRef);
                  isFirebaseEnabled = true;
                  
                  console.log("Firestore接続成功（RTDB互換アダプタ）");
                  setIsFirebaseReady(true);
                } catch (err) {
                  console.error("Firestore接続エラー:", err);
                  setFirebaseError("データベースへの接続に失敗しました: " + err.message);
                }
              } else {
                // 未ログイン
                setIsAuthenticated(false);
                setIsFirebaseReady(false);
              }
              setIsChecking(false);
            });
          } catch (e) {
            console.error("Firebase初期化エラー:", e);
            setFirebaseError("Firebase初期化エラー: " + e.message);
            setIsChecking(false);
          }
        };

        initFirebase();

        return () => {
          if (unsubscribe) unsubscribe();
        };
      }, []);

      const handleLogout = () => {
        firebase.auth().signOut().then(() => {
          setIsAuthenticated(false);
        });
      };

      if (isChecking) {
        return (
          <div className="min-h-screen flex items-center justify-center bg-gray-50">
            <div className="text-gray-500">読み込み中...</div>
          </div>
        );
      }

      if (!isAuthenticated) {
        return <LoginScreen />;
      }

      // アプリ認証後、Firebase準備待ち
      if (firebaseError) {
        return (
          <div className="min-h-screen flex items-center justify-center bg-gray-50">
            <div className="bg-white p-6 rounded shadow-lg border-l-4 border-red-500 max-w-md">
              <h3 className="text-red-600 font-bold mb-2">エラーが発生しました</h3>
              <p className="text-gray-600 text-sm">{firebaseError}</p>
              <button 
                onClick={() => window.location.reload()}
                className="mt-4 bg-gray-200 hover:bg-gray-300 text-gray-800 px-4 py-2 rounded text-sm font-bold"
              >
                再読み込み
              </button>
            </div>
          </div>
        );
      }

      if (!isFirebaseReady) {
        return (
          <div className="min-h-screen flex items-center justify-center bg-gray-50">
            <div className="flex flex-col items-center gap-3">
              <div className="animate-spin h-8 w-8 border-4 border-blue-500 border-t-transparent rounded-full"></div>
              <div className="text-blue-600 font-bold">データベース接続中...</div>
              <div className="text-xs text-gray-400">認証情報を確認しています</div>
            </div>
          </div>
        );
      }

      return <ShortStayAllocator onLogout={handleLogout} />;
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
